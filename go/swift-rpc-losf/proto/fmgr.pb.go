// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fmgr.proto

package filemgr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Volume type
type VolumeType int32

const (
	VolumeType_VOLUME_DEFAULT     VolumeType = 0
	VolumeType_VOLUME_TOMBSTONE   VolumeType = 1
	VolumeType_VOLUME_X_DELETE_AT VolumeType = 2
)

var VolumeType_name = map[int32]string{
	0: "VOLUME_DEFAULT",
	1: "VOLUME_TOMBSTONE",
	2: "VOLUME_X_DELETE_AT",
}
var VolumeType_value = map[string]int32{
	"VOLUME_DEFAULT":     0,
	"VOLUME_TOMBSTONE":   1,
	"VOLUME_X_DELETE_AT": 2,
}

func (x VolumeType) String() string {
	return proto.EnumName(VolumeType_name, int32(x))
}
func (VolumeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{0}
}

// VolumeState state
type VolumeState int32

const (
	// Default state, volume can be read from and written to
	VolumeState_STATE_RW VolumeState = 0
	// Volume is being compacted (source). New objects cannot be appended
	VolumeState_STATE_COMPACTION_SRC VolumeState = 1
	// Volume is a compaction target. New objects cannot be appended
	VolumeState_STATE_COMPACTION_TARGET VolumeState = 2
)

var VolumeState_name = map[int32]string{
	0: "STATE_RW",
	1: "STATE_COMPACTION_SRC",
	2: "STATE_COMPACTION_TARGET",
}
var VolumeState_value = map[string]int32{
	"STATE_RW":                0,
	"STATE_COMPACTION_SRC":    1,
	"STATE_COMPACTION_TARGET": 2,
}

func (x VolumeState) String() string {
	return proto.EnumName(VolumeState_name, int32(x))
}
func (VolumeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{1}
}

type ListPartitionsInfo struct {
	PartitionBits        uint32   `protobuf:"varint,1,opt,name=partition_bits,json=partitionBits,proto3" json:"partition_bits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPartitionsInfo) Reset()         { *m = ListPartitionsInfo{} }
func (m *ListPartitionsInfo) String() string { return proto.CompactTextString(m) }
func (*ListPartitionsInfo) ProtoMessage()    {}
func (*ListPartitionsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{0}
}
func (m *ListPartitionsInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPartitionsInfo.Unmarshal(m, b)
}
func (m *ListPartitionsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPartitionsInfo.Marshal(b, m, deterministic)
}
func (dst *ListPartitionsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPartitionsInfo.Merge(dst, src)
}
func (m *ListPartitionsInfo) XXX_Size() int {
	return xxx_messageInfo_ListPartitionsInfo.Size(m)
}
func (m *ListPartitionsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPartitionsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ListPartitionsInfo proto.InternalMessageInfo

func (m *ListPartitionsInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

type ListPartitionInfo struct {
	Partition            uint32   `protobuf:"varint,1,opt,name=partition,proto3" json:"partition,omitempty"`
	PartitionBits        uint32   `protobuf:"varint,2,opt,name=partition_bits,json=partitionBits,proto3" json:"partition_bits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPartitionInfo) Reset()         { *m = ListPartitionInfo{} }
func (m *ListPartitionInfo) String() string { return proto.CompactTextString(m) }
func (*ListPartitionInfo) ProtoMessage()    {}
func (*ListPartitionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{1}
}
func (m *ListPartitionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPartitionInfo.Unmarshal(m, b)
}
func (m *ListPartitionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPartitionInfo.Marshal(b, m, deterministic)
}
func (dst *ListPartitionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPartitionInfo.Merge(dst, src)
}
func (m *ListPartitionInfo) XXX_Size() int {
	return xxx_messageInfo_ListPartitionInfo.Size(m)
}
func (m *ListPartitionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPartitionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ListPartitionInfo proto.InternalMessageInfo

func (m *ListPartitionInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListPartitionInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

type ListSuffixInfo struct {
	Partition            uint32   `protobuf:"varint,1,opt,name=partition,proto3" json:"partition,omitempty"`
	Suffix               []byte   `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	PartitionBits        uint32   `protobuf:"varint,3,opt,name=partition_bits,json=partitionBits,proto3" json:"partition_bits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSuffixInfo) Reset()         { *m = ListSuffixInfo{} }
func (m *ListSuffixInfo) String() string { return proto.CompactTextString(m) }
func (*ListSuffixInfo) ProtoMessage()    {}
func (*ListSuffixInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{2}
}
func (m *ListSuffixInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSuffixInfo.Unmarshal(m, b)
}
func (m *ListSuffixInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSuffixInfo.Marshal(b, m, deterministic)
}
func (dst *ListSuffixInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSuffixInfo.Merge(dst, src)
}
func (m *ListSuffixInfo) XXX_Size() int {
	return xxx_messageInfo_ListSuffixInfo.Size(m)
}
func (m *ListSuffixInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSuffixInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ListSuffixInfo proto.InternalMessageInfo

func (m *ListSuffixInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListSuffixInfo) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *ListSuffixInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

// Generic reply message for List* functions (listdir like)
type DirEntries struct {
	Entry                []string `protobuf:"bytes,1,rep,name=entry,proto3" json:"entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DirEntries) Reset()         { *m = DirEntries{} }
func (m *DirEntries) String() string { return proto.CompactTextString(m) }
func (*DirEntries) ProtoMessage()    {}
func (*DirEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{3}
}
func (m *DirEntries) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DirEntries.Unmarshal(m, b)
}
func (m *DirEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DirEntries.Marshal(b, m, deterministic)
}
func (dst *DirEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirEntries.Merge(dst, src)
}
func (m *DirEntries) XXX_Size() int {
	return xxx_messageInfo_DirEntries.Size(m)
}
func (m *DirEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_DirEntries.DiscardUnknown(m)
}

var xxx_messageInfo_DirEntries proto.InternalMessageInfo

func (m *DirEntries) GetEntry() []string {
	if m != nil {
		return m.Entry
	}
	return nil
}

type VolumeIndex struct {
	Index uint32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,3,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeIndex) Reset()         { *m = VolumeIndex{} }
func (m *VolumeIndex) String() string { return proto.CompactTextString(m) }
func (*VolumeIndex) ProtoMessage()    {}
func (*VolumeIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{4}
}
func (m *VolumeIndex) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeIndex.Unmarshal(m, b)
}
func (m *VolumeIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeIndex.Marshal(b, m, deterministic)
}
func (dst *VolumeIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeIndex.Merge(dst, src)
}
func (m *VolumeIndex) XXX_Size() int {
	return xxx_messageInfo_VolumeIndex.Size(m)
}
func (m *VolumeIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeIndex.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeIndex proto.InternalMessageInfo

func (m *VolumeIndex) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *VolumeIndex) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Volume struct {
	VolumeIndex          uint32   `protobuf:"varint,1,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	VolumeType           uint32   `protobuf:"varint,2,opt,name=volume_type,json=volumeType,proto3" json:"volume_type,omitempty"`
	VolumeState          uint32   `protobuf:"varint,3,opt,name=volume_state,json=volumeState,proto3" json:"volume_state,omitempty"`
	Partition            uint32   `protobuf:"varint,4,opt,name=partition,proto3" json:"partition,omitempty"`
	NextOffset           uint64   `protobuf:"varint,5,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}
func (*Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{5}
}
func (m *Volume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Volume.Unmarshal(m, b)
}
func (m *Volume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Volume.Marshal(b, m, deterministic)
}
func (dst *Volume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volume.Merge(dst, src)
}
func (m *Volume) XXX_Size() int {
	return xxx_messageInfo_Volume.Size(m)
}
func (m *Volume) XXX_DiscardUnknown() {
	xxx_messageInfo_Volume.DiscardUnknown(m)
}

var xxx_messageInfo_Volume proto.InternalMessageInfo

func (m *Volume) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *Volume) GetVolumeType() uint32 {
	if m != nil {
		return m.VolumeType
	}
	return 0
}

func (m *Volume) GetVolumeState() uint32 {
	if m != nil {
		return m.VolumeState
	}
	return 0
}

func (m *Volume) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Volume) GetNextOffset() uint64 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

// Similar to volume but we don't want to require the
// partition
type GetNextOffsetInfo struct {
	VolumeIndex uint32 `protobuf:"varint,1,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	VolumeType  uint32 `protobuf:"varint,2,opt,name=volume_type,json=volumeType,proto3" json:"volume_type,omitempty"`
	VolumeState uint32 `protobuf:"varint,3,opt,name=volume_state,json=volumeState,proto3" json:"volume_state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,4,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNextOffsetInfo) Reset()         { *m = GetNextOffsetInfo{} }
func (m *GetNextOffsetInfo) String() string { return proto.CompactTextString(m) }
func (*GetNextOffsetInfo) ProtoMessage()    {}
func (*GetNextOffsetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{6}
}
func (m *GetNextOffsetInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNextOffsetInfo.Unmarshal(m, b)
}
func (m *GetNextOffsetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNextOffsetInfo.Marshal(b, m, deterministic)
}
func (dst *GetNextOffsetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNextOffsetInfo.Merge(dst, src)
}
func (m *GetNextOffsetInfo) XXX_Size() int {
	return xxx_messageInfo_GetNextOffsetInfo.Size(m)
}
func (m *GetNextOffsetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNextOffsetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GetNextOffsetInfo proto.InternalMessageInfo

func (m *GetNextOffsetInfo) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *GetNextOffsetInfo) GetVolumeType() uint32 {
	if m != nil {
		return m.VolumeType
	}
	return 0
}

func (m *GetNextOffsetInfo) GetVolumeState() uint32 {
	if m != nil {
		return m.VolumeState
	}
	return 0
}

func (m *GetNextOffsetInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type ListVolumesInfo struct {
	Partition uint32     `protobuf:"varint,1,opt,name=partition,proto3" json:"partition,omitempty"`
	Type      VolumeType `protobuf:"varint,2,opt,name=type,proto3,enum=filemgr.VolumeType" json:"type,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,3,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListVolumesInfo) Reset()         { *m = ListVolumesInfo{} }
func (m *ListVolumesInfo) String() string { return proto.CompactTextString(m) }
func (*ListVolumesInfo) ProtoMessage()    {}
func (*ListVolumesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{7}
}
func (m *ListVolumesInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListVolumesInfo.Unmarshal(m, b)
}
func (m *ListVolumesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListVolumesInfo.Marshal(b, m, deterministic)
}
func (dst *ListVolumesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumesInfo.Merge(dst, src)
}
func (m *ListVolumesInfo) XXX_Size() int {
	return xxx_messageInfo_ListVolumesInfo.Size(m)
}
func (m *ListVolumesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumesInfo proto.InternalMessageInfo

func (m *ListVolumesInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListVolumesInfo) GetType() VolumeType {
	if m != nil {
		return m.Type
	}
	return VolumeType_VOLUME_DEFAULT
}

func (m *ListVolumesInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Volumes struct {
	Volumes              []*Volume `protobuf:"bytes,1,rep,name=volumes,proto3" json:"volumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Volumes) Reset()         { *m = Volumes{} }
func (m *Volumes) String() string { return proto.CompactTextString(m) }
func (*Volumes) ProtoMessage()    {}
func (*Volumes) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{8}
}
func (m *Volumes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Volumes.Unmarshal(m, b)
}
func (m *Volumes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Volumes.Marshal(b, m, deterministic)
}
func (dst *Volumes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volumes.Merge(dst, src)
}
func (m *Volumes) XXX_Size() int {
	return xxx_messageInfo_Volumes.Size(m)
}
func (m *Volumes) XXX_DiscardUnknown() {
	xxx_messageInfo_Volumes.DiscardUnknown(m)
}

var xxx_messageInfo_Volumes proto.InternalMessageInfo

func (m *Volumes) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

// The response message to GetNextOffset
type VolumeNextOffset struct {
	Offset               uint64   `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeNextOffset) Reset()         { *m = VolumeNextOffset{} }
func (m *VolumeNextOffset) String() string { return proto.CompactTextString(m) }
func (*VolumeNextOffset) ProtoMessage()    {}
func (*VolumeNextOffset) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{9}
}
func (m *VolumeNextOffset) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeNextOffset.Unmarshal(m, b)
}
func (m *VolumeNextOffset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeNextOffset.Marshal(b, m, deterministic)
}
func (dst *VolumeNextOffset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeNextOffset.Merge(dst, src)
}
func (m *VolumeNextOffset) XXX_Size() int {
	return xxx_messageInfo_VolumeNextOffset.Size(m)
}
func (m *VolumeNextOffset) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeNextOffset.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeNextOffset proto.InternalMessageInfo

func (m *VolumeNextOffset) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// The request message for a new volume
type NewVolumeInfo struct {
	// Swift partition
	Partition uint32     `protobuf:"varint,1,opt,name=partition,proto3" json:"partition,omitempty"`
	Type      VolumeType `protobuf:"varint,2,opt,name=type,proto3,enum=filemgr.VolumeType" json:"type,omitempty"`
	// Index number of the volume. It is up to the client to map this to an actual filename.
	VolumeIndex uint32 `protobuf:"varint,3,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	// Next available offset to use in the volume.
	Offset uint64      `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	State  VolumeState `protobuf:"varint,5,opt,name=state,proto3,enum=filemgr.VolumeState" json:"state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,6,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewVolumeInfo) Reset()         { *m = NewVolumeInfo{} }
func (m *NewVolumeInfo) String() string { return proto.CompactTextString(m) }
func (*NewVolumeInfo) ProtoMessage()    {}
func (*NewVolumeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{10}
}
func (m *NewVolumeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewVolumeInfo.Unmarshal(m, b)
}
func (m *NewVolumeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewVolumeInfo.Marshal(b, m, deterministic)
}
func (dst *NewVolumeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewVolumeInfo.Merge(dst, src)
}
func (m *NewVolumeInfo) XXX_Size() int {
	return xxx_messageInfo_NewVolumeInfo.Size(m)
}
func (m *NewVolumeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NewVolumeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NewVolumeInfo proto.InternalMessageInfo

func (m *NewVolumeInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *NewVolumeInfo) GetType() VolumeType {
	if m != nil {
		return m.Type
	}
	return VolumeType_VOLUME_DEFAULT
}

func (m *NewVolumeInfo) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *NewVolumeInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *NewVolumeInfo) GetState() VolumeState {
	if m != nil {
		return m.State
	}
	return VolumeState_STATE_RW
}

func (m *NewVolumeInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type NewVolumeState struct {
	VolumeIndex uint32      `protobuf:"varint,1,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	State       VolumeState `protobuf:"varint,2,opt,name=state,proto3,enum=filemgr.VolumeState" json:"state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,3,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewVolumeState) Reset()         { *m = NewVolumeState{} }
func (m *NewVolumeState) String() string { return proto.CompactTextString(m) }
func (*NewVolumeState) ProtoMessage()    {}
func (*NewVolumeState) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{11}
}
func (m *NewVolumeState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewVolumeState.Unmarshal(m, b)
}
func (m *NewVolumeState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewVolumeState.Marshal(b, m, deterministic)
}
func (dst *NewVolumeState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewVolumeState.Merge(dst, src)
}
func (m *NewVolumeState) XXX_Size() int {
	return xxx_messageInfo_NewVolumeState.Size(m)
}
func (m *NewVolumeState) XXX_DiscardUnknown() {
	xxx_messageInfo_NewVolumeState.DiscardUnknown(m)
}

var xxx_messageInfo_NewVolumeState proto.InternalMessageInfo

func (m *NewVolumeState) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *NewVolumeState) GetState() VolumeState {
	if m != nil {
		return m.State
	}
	return VolumeState_STATE_RW
}

func (m *NewVolumeState) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The response message for a new volume
type NewVolumeReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewVolumeReply) Reset()         { *m = NewVolumeReply{} }
func (m *NewVolumeReply) String() string { return proto.CompactTextString(m) }
func (*NewVolumeReply) ProtoMessage()    {}
func (*NewVolumeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{12}
}
func (m *NewVolumeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewVolumeReply.Unmarshal(m, b)
}
func (m *NewVolumeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewVolumeReply.Marshal(b, m, deterministic)
}
func (dst *NewVolumeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewVolumeReply.Merge(dst, src)
}
func (m *NewVolumeReply) XXX_Size() int {
	return xxx_messageInfo_NewVolumeReply.Size(m)
}
func (m *NewVolumeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NewVolumeReply.DiscardUnknown(m)
}

var xxx_messageInfo_NewVolumeReply proto.InternalMessageInfo

type DelObjectReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelObjectReply) Reset()         { *m = DelObjectReply{} }
func (m *DelObjectReply) String() string { return proto.CompactTextString(m) }
func (*DelObjectReply) ProtoMessage()    {}
func (*DelObjectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{13}
}
func (m *DelObjectReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DelObjectReply.Unmarshal(m, b)
}
func (m *DelObjectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DelObjectReply.Marshal(b, m, deterministic)
}
func (dst *DelObjectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelObjectReply.Merge(dst, src)
}
func (m *DelObjectReply) XXX_Size() int {
	return xxx_messageInfo_DelObjectReply.Size(m)
}
func (m *DelObjectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DelObjectReply.DiscardUnknown(m)
}

var xxx_messageInfo_DelObjectReply proto.InternalMessageInfo

type RenameReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenameReply) Reset()         { *m = RenameReply{} }
func (m *RenameReply) String() string { return proto.CompactTextString(m) }
func (*RenameReply) ProtoMessage()    {}
func (*RenameReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{14}
}
func (m *RenameReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RenameReply.Unmarshal(m, b)
}
func (m *RenameReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RenameReply.Marshal(b, m, deterministic)
}
func (dst *RenameReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameReply.Merge(dst, src)
}
func (m *RenameReply) XXX_Size() int {
	return xxx_messageInfo_RenameReply.Size(m)
}
func (m *RenameReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameReply.DiscardUnknown(m)
}

var xxx_messageInfo_RenameReply proto.InternalMessageInfo

// The request message for a new object
type NewObjectInfo struct {
	// Object "name". Name made of (md5, timestamp, etc..)
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Index number of the volume.
	VolumeIndex uint32 `protobuf:"varint,2,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	// Start offset of the object in the volume.
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// Next available offset to use in the volume.
	NextOffset uint64 `protobuf:"varint,4,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,5,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewObjectInfo) Reset()         { *m = NewObjectInfo{} }
func (m *NewObjectInfo) String() string { return proto.CompactTextString(m) }
func (*NewObjectInfo) ProtoMessage()    {}
func (*NewObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{15}
}
func (m *NewObjectInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewObjectInfo.Unmarshal(m, b)
}
func (m *NewObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewObjectInfo.Marshal(b, m, deterministic)
}
func (dst *NewObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewObjectInfo.Merge(dst, src)
}
func (m *NewObjectInfo) XXX_Size() int {
	return xxx_messageInfo_NewObjectInfo.Size(m)
}
func (m *NewObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NewObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NewObjectInfo proto.InternalMessageInfo

func (m *NewObjectInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NewObjectInfo) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *NewObjectInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *NewObjectInfo) GetNextOffset() uint64 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

func (m *NewObjectInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The response message for a new object
// Currently empty, but we may want to return something in the future
type NewObjectReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewObjectReply) Reset()         { *m = NewObjectReply{} }
func (m *NewObjectReply) String() string { return proto.CompactTextString(m) }
func (*NewObjectReply) ProtoMessage()    {}
func (*NewObjectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{16}
}
func (m *NewObjectReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewObjectReply.Unmarshal(m, b)
}
func (m *NewObjectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewObjectReply.Marshal(b, m, deterministic)
}
func (dst *NewObjectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewObjectReply.Merge(dst, src)
}
func (m *NewObjectReply) XXX_Size() int {
	return xxx_messageInfo_NewObjectReply.Size(m)
}
func (m *NewObjectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NewObjectReply.DiscardUnknown(m)
}

var xxx_messageInfo_NewObjectReply proto.InternalMessageInfo

type QuarantinedObjectName struct {
	Name                 []byte   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QuarantinedObjectName) Reset()         { *m = QuarantinedObjectName{} }
func (m *QuarantinedObjectName) String() string { return proto.CompactTextString(m) }
func (*QuarantinedObjectName) ProtoMessage()    {}
func (*QuarantinedObjectName) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{17}
}
func (m *QuarantinedObjectName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuarantinedObjectName.Unmarshal(m, b)
}
func (m *QuarantinedObjectName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuarantinedObjectName.Marshal(b, m, deterministic)
}
func (dst *QuarantinedObjectName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuarantinedObjectName.Merge(dst, src)
}
func (m *QuarantinedObjectName) XXX_Size() int {
	return xxx_messageInfo_QuarantinedObjectName.Size(m)
}
func (m *QuarantinedObjectName) XXX_DiscardUnknown() {
	xxx_messageInfo_QuarantinedObjectName.DiscardUnknown(m)
}

var xxx_messageInfo_QuarantinedObjectName proto.InternalMessageInfo

func (m *QuarantinedObjectName) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

type ObjectName struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,2,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectName) Reset()         { *m = ObjectName{} }
func (m *ObjectName) String() string { return proto.CompactTextString(m) }
func (*ObjectName) ProtoMessage()    {}
func (*ObjectName) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{18}
}
func (m *ObjectName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ObjectName.Unmarshal(m, b)
}
func (m *ObjectName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ObjectName.Marshal(b, m, deterministic)
}
func (dst *ObjectName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectName.Merge(dst, src)
}
func (m *ObjectName) XXX_Size() int {
	return xxx_messageInfo_ObjectName.Size(m)
}
func (m *ObjectName) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectName.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectName proto.InternalMessageInfo

func (m *ObjectName) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *ObjectName) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type LoadObjectInfo struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Is it quarantined ?
	IsQuarantined bool `protobuf:"varint,2,opt,name=is_quarantined,json=isQuarantined,proto3" json:"is_quarantined,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,3,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadObjectInfo) Reset()         { *m = LoadObjectInfo{} }
func (m *LoadObjectInfo) String() string { return proto.CompactTextString(m) }
func (*LoadObjectInfo) ProtoMessage()    {}
func (*LoadObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{19}
}
func (m *LoadObjectInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadObjectInfo.Unmarshal(m, b)
}
func (m *LoadObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadObjectInfo.Marshal(b, m, deterministic)
}
func (dst *LoadObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadObjectInfo.Merge(dst, src)
}
func (m *LoadObjectInfo) XXX_Size() int {
	return xxx_messageInfo_LoadObjectInfo.Size(m)
}
func (m *LoadObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LoadObjectInfo proto.InternalMessageInfo

func (m *LoadObjectInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *LoadObjectInfo) GetIsQuarantined() bool {
	if m != nil {
		return m.IsQuarantined
	}
	return false
}

func (m *LoadObjectInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The request message to rename an object
type RenameInfo struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// new name of the object
	NewName []byte `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,3,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenameInfo) Reset()         { *m = RenameInfo{} }
func (m *RenameInfo) String() string { return proto.CompactTextString(m) }
func (*RenameInfo) ProtoMessage()    {}
func (*RenameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{20}
}
func (m *RenameInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RenameInfo.Unmarshal(m, b)
}
func (m *RenameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RenameInfo.Marshal(b, m, deterministic)
}
func (dst *RenameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameInfo.Merge(dst, src)
}
func (m *RenameInfo) XXX_Size() int {
	return xxx_messageInfo_RenameInfo.Size(m)
}
func (m *RenameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RenameInfo proto.InternalMessageInfo

func (m *RenameInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *RenameInfo) GetNewName() []byte {
	if m != nil {
		return m.NewName
	}
	return nil
}

func (m *RenameInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Object struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Index number of the volume.
	VolumeIndex uint32 `protobuf:"varint,2,opt,name=volume_index,json=volumeIndex,proto3" json:"volume_index,omitempty"`
	// Start offset of the object in the volume.
	Offset               uint64   `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{21}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Object.Unmarshal(m, b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Object.Marshal(b, m, deterministic)
}
func (dst *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(dst, src)
}
func (m *Object) XXX_Size() int {
	return xxx_messageInfo_Object.Size(m)
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Object) GetVolumeIndex() uint32 {
	if m != nil {
		return m.VolumeIndex
	}
	return 0
}

func (m *Object) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type LoadObjectsResponse struct {
	Objects              []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LoadObjectsResponse) Reset()         { *m = LoadObjectsResponse{} }
func (m *LoadObjectsResponse) String() string { return proto.CompactTextString(m) }
func (*LoadObjectsResponse) ProtoMessage()    {}
func (*LoadObjectsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{22}
}
func (m *LoadObjectsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadObjectsResponse.Unmarshal(m, b)
}
func (m *LoadObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadObjectsResponse.Marshal(b, m, deterministic)
}
func (dst *LoadObjectsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadObjectsResponse.Merge(dst, src)
}
func (m *LoadObjectsResponse) XXX_Size() int {
	return xxx_messageInfo_LoadObjectsResponse.Size(m)
}
func (m *LoadObjectsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadObjectsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoadObjectsResponse proto.InternalMessageInfo

func (m *LoadObjectsResponse) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

type ObjectPrefix struct {
	Prefix []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool           bool     `protobuf:"varint,2,opt,name=repair_tool,json=repairTool,proto3" json:"repair_tool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectPrefix) Reset()         { *m = ObjectPrefix{} }
func (m *ObjectPrefix) String() string { return proto.CompactTextString(m) }
func (*ObjectPrefix) ProtoMessage()    {}
func (*ObjectPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{23}
}
func (m *ObjectPrefix) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ObjectPrefix.Unmarshal(m, b)
}
func (m *ObjectPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ObjectPrefix.Marshal(b, m, deterministic)
}
func (dst *ObjectPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectPrefix.Merge(dst, src)
}
func (m *ObjectPrefix) XXX_Size() int {
	return xxx_messageInfo_ObjectPrefix.Size(m)
}
func (m *ObjectPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectPrefix proto.InternalMessageInfo

func (m *ObjectPrefix) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ObjectPrefix) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{24}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type GetStatsInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStatsInfo) Reset()         { *m = GetStatsInfo{} }
func (m *GetStatsInfo) String() string { return proto.CompactTextString(m) }
func (*GetStatsInfo) ProtoMessage()    {}
func (*GetStatsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{25}
}
func (m *GetStatsInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetStatsInfo.Unmarshal(m, b)
}
func (m *GetStatsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetStatsInfo.Marshal(b, m, deterministic)
}
func (dst *GetStatsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStatsInfo.Merge(dst, src)
}
func (m *GetStatsInfo) XXX_Size() int {
	return xxx_messageInfo_GetStatsInfo.Size(m)
}
func (m *GetStatsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStatsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GetStatsInfo proto.InternalMessageInfo

type PartitionContent struct {
	FileEntries          []*FullPathEntry `protobuf:"bytes,1,rep,name=file_entries,json=fileEntries,proto3" json:"file_entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PartitionContent) Reset()         { *m = PartitionContent{} }
func (m *PartitionContent) String() string { return proto.CompactTextString(m) }
func (*PartitionContent) ProtoMessage()    {}
func (*PartitionContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{26}
}
func (m *PartitionContent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PartitionContent.Unmarshal(m, b)
}
func (m *PartitionContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PartitionContent.Marshal(b, m, deterministic)
}
func (dst *PartitionContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionContent.Merge(dst, src)
}
func (m *PartitionContent) XXX_Size() int {
	return xxx_messageInfo_PartitionContent.Size(m)
}
func (m *PartitionContent) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionContent.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionContent proto.InternalMessageInfo

func (m *PartitionContent) GetFileEntries() []*FullPathEntry {
	if m != nil {
		return m.FileEntries
	}
	return nil
}

type FullPathEntry struct {
	// We could add the partition if needed
	Suffix               []byte   `protobuf:"bytes,1,opt,name=suffix,proto3" json:"suffix,omitempty"`
	Ohash                []byte   `protobuf:"bytes,2,opt,name=ohash,proto3" json:"ohash,omitempty"`
	Filename             []byte   `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FullPathEntry) Reset()         { *m = FullPathEntry{} }
func (m *FullPathEntry) String() string { return proto.CompactTextString(m) }
func (*FullPathEntry) ProtoMessage()    {}
func (*FullPathEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{27}
}
func (m *FullPathEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FullPathEntry.Unmarshal(m, b)
}
func (m *FullPathEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FullPathEntry.Marshal(b, m, deterministic)
}
func (dst *FullPathEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FullPathEntry.Merge(dst, src)
}
func (m *FullPathEntry) XXX_Size() int {
	return xxx_messageInfo_FullPathEntry.Size(m)
}
func (m *FullPathEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_FullPathEntry.DiscardUnknown(m)
}

var xxx_messageInfo_FullPathEntry proto.InternalMessageInfo

func (m *FullPathEntry) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *FullPathEntry) GetOhash() []byte {
	if m != nil {
		return m.Ohash
	}
	return nil
}

func (m *FullPathEntry) GetFilename() []byte {
	if m != nil {
		return m.Filename
	}
	return nil
}

type KvState struct {
	IsClean              bool     `protobuf:"varint,1,opt,name=isClean,proto3" json:"isClean,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KvState) Reset()         { *m = KvState{} }
func (m *KvState) String() string { return proto.CompactTextString(m) }
func (*KvState) ProtoMessage()    {}
func (*KvState) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{28}
}
func (m *KvState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KvState.Unmarshal(m, b)
}
func (m *KvState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KvState.Marshal(b, m, deterministic)
}
func (dst *KvState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KvState.Merge(dst, src)
}
func (m *KvState) XXX_Size() int {
	return xxx_messageInfo_KvState.Size(m)
}
func (m *KvState) XXX_DiscardUnknown() {
	xxx_messageInfo_KvState.DiscardUnknown(m)
}

var xxx_messageInfo_KvState proto.InternalMessageInfo

func (m *KvState) GetIsClean() bool {
	if m != nil {
		return m.IsClean
	}
	return false
}

// KV stats
type KVStats struct {
	Stats                map[string]uint64 `protobuf:"bytes,1,rep,name=stats,proto3" json:"stats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *KVStats) Reset()         { *m = KVStats{} }
func (m *KVStats) String() string { return proto.CompactTextString(m) }
func (*KVStats) ProtoMessage()    {}
func (*KVStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_fmgr_9bd830dff177b0b0, []int{29}
}
func (m *KVStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KVStats.Unmarshal(m, b)
}
func (m *KVStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KVStats.Marshal(b, m, deterministic)
}
func (dst *KVStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVStats.Merge(dst, src)
}
func (m *KVStats) XXX_Size() int {
	return xxx_messageInfo_KVStats.Size(m)
}
func (m *KVStats) XXX_DiscardUnknown() {
	xxx_messageInfo_KVStats.DiscardUnknown(m)
}

var xxx_messageInfo_KVStats proto.InternalMessageInfo

func (m *KVStats) GetStats() map[string]uint64 {
	if m != nil {
		return m.Stats
	}
	return nil
}

func init() {
	proto.RegisterType((*ListPartitionsInfo)(nil), "filemgr.ListPartitionsInfo")
	proto.RegisterType((*ListPartitionInfo)(nil), "filemgr.ListPartitionInfo")
	proto.RegisterType((*ListSuffixInfo)(nil), "filemgr.ListSuffixInfo")
	proto.RegisterType((*DirEntries)(nil), "filemgr.DirEntries")
	proto.RegisterType((*VolumeIndex)(nil), "filemgr.VolumeIndex")
	proto.RegisterType((*Volume)(nil), "filemgr.Volume")
	proto.RegisterType((*GetNextOffsetInfo)(nil), "filemgr.GetNextOffsetInfo")
	proto.RegisterType((*ListVolumesInfo)(nil), "filemgr.ListVolumesInfo")
	proto.RegisterType((*Volumes)(nil), "filemgr.Volumes")
	proto.RegisterType((*VolumeNextOffset)(nil), "filemgr.VolumeNextOffset")
	proto.RegisterType((*NewVolumeInfo)(nil), "filemgr.NewVolumeInfo")
	proto.RegisterType((*NewVolumeState)(nil), "filemgr.NewVolumeState")
	proto.RegisterType((*NewVolumeReply)(nil), "filemgr.NewVolumeReply")
	proto.RegisterType((*DelObjectReply)(nil), "filemgr.DelObjectReply")
	proto.RegisterType((*RenameReply)(nil), "filemgr.RenameReply")
	proto.RegisterType((*NewObjectInfo)(nil), "filemgr.NewObjectInfo")
	proto.RegisterType((*NewObjectReply)(nil), "filemgr.NewObjectReply")
	proto.RegisterType((*QuarantinedObjectName)(nil), "filemgr.QuarantinedObjectName")
	proto.RegisterType((*ObjectName)(nil), "filemgr.ObjectName")
	proto.RegisterType((*LoadObjectInfo)(nil), "filemgr.LoadObjectInfo")
	proto.RegisterType((*RenameInfo)(nil), "filemgr.RenameInfo")
	proto.RegisterType((*Object)(nil), "filemgr.Object")
	proto.RegisterType((*LoadObjectsResponse)(nil), "filemgr.LoadObjectsResponse")
	proto.RegisterType((*ObjectPrefix)(nil), "filemgr.ObjectPrefix")
	proto.RegisterType((*Empty)(nil), "filemgr.Empty")
	proto.RegisterType((*GetStatsInfo)(nil), "filemgr.GetStatsInfo")
	proto.RegisterType((*PartitionContent)(nil), "filemgr.PartitionContent")
	proto.RegisterType((*FullPathEntry)(nil), "filemgr.FullPathEntry")
	proto.RegisterType((*KvState)(nil), "filemgr.KvState")
	proto.RegisterType((*KVStats)(nil), "filemgr.KVStats")
	proto.RegisterMapType((map[string]uint64)(nil), "filemgr.KVStats.StatsEntry")
	proto.RegisterEnum("filemgr.VolumeType", VolumeType_name, VolumeType_value)
	proto.RegisterEnum("filemgr.VolumeState", VolumeState_name, VolumeState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileMgrClient is the client API for FileMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileMgrClient interface {
	// Register a new Volume
	RegisterVolume(ctx context.Context, in *NewVolumeInfo, opts ...grpc.CallOption) (*NewVolumeReply, error)
	// Unregister a Volume
	UnregisterVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (*Empty, error)
	// Register a new object
	RegisterObject(ctx context.Context, in *NewObjectInfo, opts ...grpc.CallOption) (*NewObjectReply, error)
	// Unregister an object
	UnregisterObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*DelObjectReply, error)
	// Rename an object
	RenameObject(ctx context.Context, in *RenameInfo, opts ...grpc.CallOption) (*RenameReply, error)
	// Quarantine a "directory" (all objects "below" ohash)
	// DEPRECATED
	QuarantineDir(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*DelObjectReply, error)
	// Quarantine an object
	QuarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error)
	// Unquarantine an object
	UnquarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error)
	// Get array of object locations
	LoadObjectsByPrefix(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error)
	// List Volumes
	ListVolumes(ctx context.Context, in *ListVolumesInfo, opts ...grpc.CallOption) (*Volumes, error)
	// Get Volume by index
	GetVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (*Volume, error)
	// List partitions
	ListPartitions(ctx context.Context, in *ListPartitionsInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// List suffixes within partition
	ListPartition(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// List object hashes within partition/suffix
	ListSuffix(ctx context.Context, in *ListSuffixInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// Recursively list the partition content, down to files
	ListPartitionRecursive(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*PartitionContent, error)
	// List quarantined objects. This may be very large, so use a stream (no eventlet)
	ListQuarantinedOHashes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FileMgr_ListQuarantinedOHashesClient, error)
	// List files within a quarantined object (ohash)
	ListQuarantinedOHash(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error)
	// Get object
	LoadObject(ctx context.Context, in *LoadObjectInfo, opts ...grpc.CallOption) (*Object, error)
	// Get next offset to write to in a volume
	GetNextOffset(ctx context.Context, in *GetNextOffsetInfo, opts ...grpc.CallOption) (*VolumeNextOffset, error)
	// Get KVStats
	GetStats(ctx context.Context, in *GetStatsInfo, opts ...grpc.CallOption) (*KVStats, error)
	// List objects per volume - used for compaction (no eventlet, ok to use stream)
	LoadObjectsByVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (FileMgr_LoadObjectsByVolumeClient, error)
	// Update Volume state
	UpdateVolumeState(ctx context.Context, in *NewVolumeState, opts ...grpc.CallOption) (*Empty, error)
	// Set state (clean: in sync with the volumes)
	SetKvState(ctx context.Context, in *KvState, opts ...grpc.CallOption) (*Empty, error)
	// Get state (clean: in sync with the volumes)
	GetKvState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KvState, error)
}

type fileMgrClient struct {
	cc *grpc.ClientConn
}

func NewFileMgrClient(cc *grpc.ClientConn) FileMgrClient {
	return &fileMgrClient{cc}
}

func (c *fileMgrClient) RegisterVolume(ctx context.Context, in *NewVolumeInfo, opts ...grpc.CallOption) (*NewVolumeReply, error) {
	out := new(NewVolumeReply)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/RegisterVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnregisterVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/UnregisterVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) RegisterObject(ctx context.Context, in *NewObjectInfo, opts ...grpc.CallOption) (*NewObjectReply, error) {
	out := new(NewObjectReply)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/RegisterObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnregisterObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*DelObjectReply, error) {
	out := new(DelObjectReply)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/UnregisterObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) RenameObject(ctx context.Context, in *RenameInfo, opts ...grpc.CallOption) (*RenameReply, error) {
	out := new(RenameReply)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/RenameObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) QuarantineDir(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*DelObjectReply, error) {
	out := new(DelObjectReply)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/QuarantineDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) QuarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/QuarantineObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnquarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/UnquarantineObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObjectsByPrefix(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error) {
	out := new(LoadObjectsResponse)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/LoadObjectsByPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListVolumes(ctx context.Context, in *ListVolumesInfo, opts ...grpc.CallOption) (*Volumes, error) {
	out := new(Volumes)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListVolumes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (*Volume, error) {
	out := new(Volume)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/GetVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartitions(ctx context.Context, in *ListPartitionsInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListPartitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartition(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListPartition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListSuffix(ctx context.Context, in *ListSuffixInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListSuffix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartitionRecursive(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*PartitionContent, error) {
	out := new(PartitionContent)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListPartitionRecursive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListQuarantinedOHashes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FileMgr_ListQuarantinedOHashesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileMgr_serviceDesc.Streams[0], "/filemgr.FileMgr/ListQuarantinedOHashes", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileMgrListQuarantinedOHashesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileMgr_ListQuarantinedOHashesClient interface {
	Recv() (*QuarantinedObjectName, error)
	grpc.ClientStream
}

type fileMgrListQuarantinedOHashesClient struct {
	grpc.ClientStream
}

func (x *fileMgrListQuarantinedOHashesClient) Recv() (*QuarantinedObjectName, error) {
	m := new(QuarantinedObjectName)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileMgrClient) ListQuarantinedOHash(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error) {
	out := new(LoadObjectsResponse)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/ListQuarantinedOHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObject(ctx context.Context, in *LoadObjectInfo, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/LoadObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetNextOffset(ctx context.Context, in *GetNextOffsetInfo, opts ...grpc.CallOption) (*VolumeNextOffset, error) {
	out := new(VolumeNextOffset)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/GetNextOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetStats(ctx context.Context, in *GetStatsInfo, opts ...grpc.CallOption) (*KVStats, error) {
	out := new(KVStats)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/GetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObjectsByVolume(ctx context.Context, in *VolumeIndex, opts ...grpc.CallOption) (FileMgr_LoadObjectsByVolumeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileMgr_serviceDesc.Streams[1], "/filemgr.FileMgr/LoadObjectsByVolume", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileMgrLoadObjectsByVolumeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileMgr_LoadObjectsByVolumeClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type fileMgrLoadObjectsByVolumeClient struct {
	grpc.ClientStream
}

func (x *fileMgrLoadObjectsByVolumeClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileMgrClient) UpdateVolumeState(ctx context.Context, in *NewVolumeState, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/UpdateVolumeState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) SetKvState(ctx context.Context, in *KvState, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/SetKvState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetKvState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KvState, error) {
	out := new(KvState)
	err := c.cc.Invoke(ctx, "/filemgr.FileMgr/GetKvState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileMgrServer is the server API for FileMgr service.
type FileMgrServer interface {
	// Register a new Volume
	RegisterVolume(context.Context, *NewVolumeInfo) (*NewVolumeReply, error)
	// Unregister a Volume
	UnregisterVolume(context.Context, *VolumeIndex) (*Empty, error)
	// Register a new object
	RegisterObject(context.Context, *NewObjectInfo) (*NewObjectReply, error)
	// Unregister an object
	UnregisterObject(context.Context, *ObjectName) (*DelObjectReply, error)
	// Rename an object
	RenameObject(context.Context, *RenameInfo) (*RenameReply, error)
	// Quarantine a "directory" (all objects "below" ohash)
	// DEPRECATED
	QuarantineDir(context.Context, *ObjectPrefix) (*DelObjectReply, error)
	// Quarantine an object
	QuarantineObject(context.Context, *ObjectName) (*Empty, error)
	// Unquarantine an object
	UnquarantineObject(context.Context, *ObjectName) (*Empty, error)
	// Get array of object locations
	LoadObjectsByPrefix(context.Context, *ObjectPrefix) (*LoadObjectsResponse, error)
	// List Volumes
	ListVolumes(context.Context, *ListVolumesInfo) (*Volumes, error)
	// Get Volume by index
	GetVolume(context.Context, *VolumeIndex) (*Volume, error)
	// List partitions
	ListPartitions(context.Context, *ListPartitionsInfo) (*DirEntries, error)
	// List suffixes within partition
	ListPartition(context.Context, *ListPartitionInfo) (*DirEntries, error)
	// List object hashes within partition/suffix
	ListSuffix(context.Context, *ListSuffixInfo) (*DirEntries, error)
	// Recursively list the partition content, down to files
	ListPartitionRecursive(context.Context, *ListPartitionInfo) (*PartitionContent, error)
	// List quarantined objects. This may be very large, so use a stream (no eventlet)
	ListQuarantinedOHashes(*Empty, FileMgr_ListQuarantinedOHashesServer) error
	// List files within a quarantined object (ohash)
	ListQuarantinedOHash(context.Context, *ObjectPrefix) (*LoadObjectsResponse, error)
	// Get object
	LoadObject(context.Context, *LoadObjectInfo) (*Object, error)
	// Get next offset to write to in a volume
	GetNextOffset(context.Context, *GetNextOffsetInfo) (*VolumeNextOffset, error)
	// Get KVStats
	GetStats(context.Context, *GetStatsInfo) (*KVStats, error)
	// List objects per volume - used for compaction (no eventlet, ok to use stream)
	LoadObjectsByVolume(*VolumeIndex, FileMgr_LoadObjectsByVolumeServer) error
	// Update Volume state
	UpdateVolumeState(context.Context, *NewVolumeState) (*Empty, error)
	// Set state (clean: in sync with the volumes)
	SetKvState(context.Context, *KvState) (*Empty, error)
	// Get state (clean: in sync with the volumes)
	GetKvState(context.Context, *Empty) (*KvState, error)
}

func RegisterFileMgrServer(s *grpc.Server, srv FileMgrServer) {
	s.RegisterService(&_FileMgr_serviceDesc, srv)
}

func _FileMgr_RegisterVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewVolumeInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RegisterVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RegisterVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RegisterVolume(ctx, req.(*NewVolumeInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnregisterVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnregisterVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnregisterVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnregisterVolume(ctx, req.(*VolumeIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_RegisterObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewObjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RegisterObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RegisterObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RegisterObject(ctx, req.(*NewObjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnregisterObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnregisterObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnregisterObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnregisterObject(ctx, req.(*ObjectName))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_RenameObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RenameObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RenameObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RenameObject(ctx, req.(*RenameInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_QuarantineDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).QuarantineDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/QuarantineDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).QuarantineDir(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_QuarantineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).QuarantineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/QuarantineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).QuarantineObject(ctx, req.(*ObjectName))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnquarantineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnquarantineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnquarantineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnquarantineObject(ctx, req.(*ObjectName))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObjectsByPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).LoadObjectsByPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/LoadObjectsByPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).LoadObjectsByPrefix(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVolumesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListVolumes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListVolumes(ctx, req.(*ListVolumesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetVolume(ctx, req.(*VolumeIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartitions(ctx, req.(*ListPartitionsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartition(ctx, req.(*ListPartitionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListSuffix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSuffixInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListSuffix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListSuffix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListSuffix(ctx, req.(*ListSuffixInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartitionRecursive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartitionRecursive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartitionRecursive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartitionRecursive(ctx, req.(*ListPartitionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListQuarantinedOHashes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileMgrServer).ListQuarantinedOHashes(m, &fileMgrListQuarantinedOHashesServer{stream})
}

type FileMgr_ListQuarantinedOHashesServer interface {
	Send(*QuarantinedObjectName) error
	grpc.ServerStream
}

type fileMgrListQuarantinedOHashesServer struct {
	grpc.ServerStream
}

func (x *fileMgrListQuarantinedOHashesServer) Send(m *QuarantinedObjectName) error {
	return x.ServerStream.SendMsg(m)
}

func _FileMgr_ListQuarantinedOHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListQuarantinedOHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListQuarantinedOHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListQuarantinedOHash(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadObjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).LoadObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/LoadObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).LoadObject(ctx, req.(*LoadObjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetNextOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextOffsetInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetNextOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetNextOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetNextOffset(ctx, req.(*GetNextOffsetInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetStats(ctx, req.(*GetStatsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObjectsByVolume_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeIndex)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileMgrServer).LoadObjectsByVolume(m, &fileMgrLoadObjectsByVolumeServer{stream})
}

type FileMgr_LoadObjectsByVolumeServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type fileMgrLoadObjectsByVolumeServer struct {
	grpc.ServerStream
}

func (x *fileMgrLoadObjectsByVolumeServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func _FileMgr_UpdateVolumeState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewVolumeState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UpdateVolumeState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UpdateVolumeState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UpdateVolumeState(ctx, req.(*NewVolumeState))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_SetKvState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).SetKvState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/SetKvState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).SetKvState(ctx, req.(*KvState))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetKvState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetKvState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetKvState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetKvState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "filemgr.FileMgr",
	HandlerType: (*FileMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterVolume",
			Handler:    _FileMgr_RegisterVolume_Handler,
		},
		{
			MethodName: "UnregisterVolume",
			Handler:    _FileMgr_UnregisterVolume_Handler,
		},
		{
			MethodName: "RegisterObject",
			Handler:    _FileMgr_RegisterObject_Handler,
		},
		{
			MethodName: "UnregisterObject",
			Handler:    _FileMgr_UnregisterObject_Handler,
		},
		{
			MethodName: "RenameObject",
			Handler:    _FileMgr_RenameObject_Handler,
		},
		{
			MethodName: "QuarantineDir",
			Handler:    _FileMgr_QuarantineDir_Handler,
		},
		{
			MethodName: "QuarantineObject",
			Handler:    _FileMgr_QuarantineObject_Handler,
		},
		{
			MethodName: "UnquarantineObject",
			Handler:    _FileMgr_UnquarantineObject_Handler,
		},
		{
			MethodName: "LoadObjectsByPrefix",
			Handler:    _FileMgr_LoadObjectsByPrefix_Handler,
		},
		{
			MethodName: "ListVolumes",
			Handler:    _FileMgr_ListVolumes_Handler,
		},
		{
			MethodName: "GetVolume",
			Handler:    _FileMgr_GetVolume_Handler,
		},
		{
			MethodName: "ListPartitions",
			Handler:    _FileMgr_ListPartitions_Handler,
		},
		{
			MethodName: "ListPartition",
			Handler:    _FileMgr_ListPartition_Handler,
		},
		{
			MethodName: "ListSuffix",
			Handler:    _FileMgr_ListSuffix_Handler,
		},
		{
			MethodName: "ListPartitionRecursive",
			Handler:    _FileMgr_ListPartitionRecursive_Handler,
		},
		{
			MethodName: "ListQuarantinedOHash",
			Handler:    _FileMgr_ListQuarantinedOHash_Handler,
		},
		{
			MethodName: "LoadObject",
			Handler:    _FileMgr_LoadObject_Handler,
		},
		{
			MethodName: "GetNextOffset",
			Handler:    _FileMgr_GetNextOffset_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _FileMgr_GetStats_Handler,
		},
		{
			MethodName: "UpdateVolumeState",
			Handler:    _FileMgr_UpdateVolumeState_Handler,
		},
		{
			MethodName: "SetKvState",
			Handler:    _FileMgr_SetKvState_Handler,
		},
		{
			MethodName: "GetKvState",
			Handler:    _FileMgr_GetKvState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListQuarantinedOHashes",
			Handler:       _FileMgr_ListQuarantinedOHashes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LoadObjectsByVolume",
			Handler:       _FileMgr_LoadObjectsByVolume_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "fmgr.proto",
}

func init() { proto.RegisterFile("fmgr.proto", fileDescriptor_fmgr_9bd830dff177b0b0) }

var fileDescriptor_fmgr_9bd830dff177b0b0 = []byte{
	// 1303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x59, 0x6f, 0xdb, 0x46,
	0x10, 0x26, 0x75, 0x7b, 0x74, 0x84, 0xd9, 0x28, 0x8e, 0xa2, 0x04, 0x4d, 0xca, 0x22, 0x68, 0xea,
	0x02, 0x46, 0x9a, 0xa6, 0x40, 0x8e, 0xa2, 0x88, 0x2c, 0x29, 0x8a, 0x11, 0x1d, 0x0e, 0x45, 0x3b,
	0x29, 0x50, 0x80, 0xa0, 0xe3, 0x95, 0xcd, 0x96, 0x26, 0x15, 0x72, 0x25, 0x5b, 0x6f, 0xfd, 0x1f,
	0x7d, 0xe9, 0x4b, 0x5f, 0xfb, 0x93, 0xfa, 0x5b, 0x0a, 0xee, 0x2e, 0x6f, 0x5a, 0x76, 0x83, 0xa0,
	0x2f, 0x02, 0x67, 0x76, 0x76, 0xe6, 0x9b, 0x63, 0x67, 0x76, 0x05, 0x30, 0x3b, 0x3d, 0x76, 0xb6,
	0xe7, 0x8e, 0x4d, 0x6c, 0x54, 0x9e, 0x19, 0x26, 0x3e, 0x3d, 0x76, 0xe4, 0x17, 0x80, 0x86, 0x86,
	0x4b, 0xf6, 0x74, 0x87, 0x18, 0xc4, 0xb0, 0x2d, 0x77, 0xd7, 0x9a, 0xd9, 0xe8, 0x01, 0x34, 0xe6,
	0x3e, 0x47, 0x3b, 0x34, 0x88, 0xdb, 0x12, 0xef, 0x8b, 0x0f, 0xeb, 0x4a, 0x3d, 0xe0, 0xee, 0x18,
	0xc4, 0x95, 0xdf, 0xc3, 0xf5, 0xd8, 0x66, 0xba, 0xf7, 0x2e, 0x6c, 0x04, 0x52, 0x7c, 0x5b, 0xc8,
	0xc8, 0xd0, 0x9c, 0xcb, 0xd2, 0x7c, 0x0a, 0x0d, 0x4f, 0xf3, 0x74, 0x31, 0x9b, 0x19, 0xe7, 0x57,
	0x50, 0xbb, 0x09, 0x25, 0x97, 0xca, 0x52, 0x75, 0x35, 0x85, 0x53, 0x19, 0xe6, 0xf2, 0x59, 0xe6,
	0x64, 0x80, 0x9e, 0xe1, 0xf4, 0x2d, 0xe2, 0x18, 0xd8, 0x45, 0x4d, 0x28, 0x62, 0x8b, 0x38, 0xab,
	0x96, 0x78, 0x3f, 0xff, 0x70, 0x43, 0x61, 0x84, 0xdc, 0x83, 0xea, 0x81, 0x6d, 0x2e, 0x4e, 0xf1,
	0xae, 0x75, 0x84, 0xcf, 0x3d, 0x21, 0xc3, 0xfb, 0xe0, 0xf8, 0x19, 0x81, 0xee, 0x41, 0xd5, 0xc1,
	0x73, 0xdd, 0x70, 0x34, 0x62, 0xdb, 0x26, 0x35, 0x56, 0x51, 0x80, 0xb1, 0x54, 0xdb, 0x36, 0xe5,
	0xbf, 0x45, 0x28, 0x31, 0x35, 0xe8, 0x4b, 0xa8, 0x2d, 0xe9, 0x97, 0xc6, 0x14, 0x31, 0xa7, 0xaa,
	0xcb, 0x88, 0x91, 0x7b, 0xc0, 0x49, 0x8d, 0xac, 0xe6, 0x98, 0x9b, 0x02, 0xc6, 0x52, 0x57, 0xf3,
	0xa8, 0x0e, 0x97, 0xe8, 0x04, 0x73, 0xef, 0xf8, 0xa6, 0xa9, 0xc7, 0x8a, 0x07, 0xae, 0x90, 0x0c,
	0xdc, 0x3d, 0xa8, 0x5a, 0xf8, 0x9c, 0x68, 0xf6, 0x6c, 0xe6, 0x62, 0xd2, 0x2a, 0xde, 0x17, 0x1f,
	0x16, 0x14, 0xf0, 0x58, 0x13, 0xca, 0x91, 0xff, 0x10, 0xe1, 0xfa, 0x00, 0x93, 0x71, 0xc0, 0xa1,
	0xd9, 0xf8, 0x9f, 0xb0, 0x27, 0xc2, 0x59, 0x48, 0x85, 0x73, 0x05, 0xd7, 0xbc, 0x3a, 0x61, 0x11,
	0x75, 0xaf, 0x50, 0x28, 0x5f, 0x43, 0x21, 0x80, 0xd3, 0x78, 0x7c, 0x63, 0x9b, 0x9f, 0x83, 0xed,
	0x83, 0x00, 0x97, 0x42, 0x05, 0x2e, 0xcf, 0xe4, 0x13, 0x28, 0x73, 0xb3, 0xe8, 0x1b, 0x28, 0x33,
	0xd4, 0x2e, 0x2d, 0x99, 0xea, 0xe3, 0x6b, 0x09, 0xbd, 0x8a, 0xbf, 0x2e, 0x6f, 0x81, 0xc4, 0x58,
	0x61, 0x40, 0xbd, 0xe2, 0xe5, 0xe1, 0x17, 0x69, 0xf8, 0x39, 0x25, 0xff, 0x23, 0x42, 0x7d, 0x8c,
	0xcf, 0xfc, 0xaa, 0xfb, 0x7c, 0xbe, 0x25, 0xb3, 0x97, 0x4f, 0x67, 0x2f, 0xc4, 0x54, 0x88, 0x62,
	0x42, 0x5b, 0x50, 0x64, 0xd9, 0x2a, 0x52, 0x23, 0xcd, 0x84, 0x11, 0x9a, 0x36, 0x85, 0x89, 0x24,
	0x43, 0x58, 0x4a, 0x85, 0xf0, 0x77, 0x11, 0x1a, 0x81, 0x83, 0x2c, 0xe3, 0x57, 0x28, 0xac, 0x00,
	0x42, 0xee, 0x3f, 0x43, 0x48, 0x67, 0x51, 0x8a, 0x20, 0x50, 0xf0, 0xdc, 0x5c, 0x79, 0x9c, 0x1e,
	0x36, 0x27, 0x87, 0xbf, 0xe2, 0x0f, 0x84, 0x71, 0xea, 0x50, 0x55, 0xb0, 0xa5, 0xfb, 0x02, 0x7f,
	0xb2, 0xb4, 0x30, 0x09, 0x9a, 0x16, 0x04, 0x05, 0x6f, 0x99, 0x82, 0xad, 0x29, 0xf4, 0x3b, 0xe5,
	0x48, 0x6e, 0x5d, 0x8c, 0xf3, 0xb1, 0x18, 0x27, 0xce, 0x64, 0x21, 0x79, 0x26, 0x93, 0x5e, 0x15,
	0x2f, 0xf0, 0x2a, 0xea, 0xc3, 0xb7, 0x70, 0xf3, 0xed, 0x42, 0x77, 0x74, 0x8b, 0x18, 0x16, 0x3e,
	0x62, 0x2b, 0x63, 0x0f, 0x67, 0x06, 0x76, 0xb9, 0x03, 0xb0, 0x5e, 0x22, 0x89, 0x20, 0x97, 0x42,
	0x60, 0x42, 0x63, 0x68, 0xeb, 0x47, 0x97, 0x04, 0xe9, 0x01, 0x34, 0x0c, 0x57, 0xfb, 0x18, 0x02,
	0xe3, 0x9a, 0xea, 0x86, 0x1b, 0x41, 0x7b, 0x79, 0x16, 0x7f, 0x01, 0x60, 0x19, 0xba, 0xd0, 0xd2,
	0x6d, 0xa8, 0x58, 0xf8, 0x4c, 0xa3, 0x7c, 0x36, 0x22, 0xca, 0x16, 0x3e, 0x1b, 0x67, 0xf8, 0x92,
	0xd6, 0xfe, 0x0e, 0x4a, 0xcc, 0x8f, 0xcf, 0x9c, 0x68, 0xf9, 0x25, 0xdc, 0x08, 0x83, 0xe4, 0x2a,
	0xd8, 0x9d, 0xdb, 0x96, 0x8b, 0xbd, 0x76, 0x62, 0x33, 0x56, 0xaa, 0x9d, 0xf0, 0x94, 0xfa, 0xeb,
	0xf2, 0x00, 0x6a, 0x8c, 0xb5, 0xe7, 0x60, 0x6f, 0xde, 0x6d, 0x42, 0x69, 0x4e, 0xbf, 0x38, 0x44,
	0x4e, 0x5d, 0x9e, 0xaf, 0x32, 0x14, 0xfb, 0xa7, 0x73, 0xb2, 0x92, 0x1b, 0x50, 0x1b, 0x60, 0xe2,
	0x1d, 0x22, 0xda, 0x4e, 0xe5, 0x11, 0x48, 0xc1, 0x7c, 0xef, 0xda, 0x16, 0xc1, 0x16, 0x41, 0xcf,
	0xa0, 0xe6, 0x01, 0xd2, 0x30, 0x1b, 0x98, 0x1c, 0xe5, 0x66, 0x80, 0xf2, 0xd5, 0xc2, 0x34, 0xf7,
	0x74, 0x72, 0xe2, 0x0d, 0xd4, 0x95, 0x52, 0xf5, 0xd8, 0x7c, 0xb6, 0xca, 0x3f, 0x43, 0x3d, 0xb6,
	0x1a, 0x99, 0xdc, 0x62, 0x6c, 0x72, 0x37, 0xa1, 0x68, 0x9f, 0xe8, 0xee, 0x09, 0xcf, 0x16, 0x23,
	0x50, 0x1b, 0x2a, 0x9e, 0x36, 0x9a, 0x84, 0x3c, 0x5d, 0x08, 0x68, 0xf9, 0x2b, 0x28, 0xbf, 0x59,
	0xb2, 0x2e, 0xd2, 0x82, 0xb2, 0xe1, 0x76, 0x4d, 0xac, 0xb3, 0x2e, 0x59, 0x51, 0x7c, 0x52, 0x5e,
	0x42, 0xf9, 0xcd, 0x01, 0xf5, 0x0e, 0x7d, 0xc7, 0xfa, 0x88, 0x0f, 0xff, 0x4e, 0x00, 0x9f, 0x0b,
	0x6c, 0xd3, 0x5f, 0xe6, 0x03, 0x93, 0x6c, 0x3f, 0x05, 0x08, 0x99, 0x48, 0x82, 0xfc, 0x6f, 0x78,
	0x45, 0x2d, 0x6c, 0x28, 0xde, 0xa7, 0x07, 0x7a, 0xa9, 0x9b, 0x0b, 0x56, 0x62, 0x05, 0x85, 0x11,
	0xcf, 0x73, 0x4f, 0xc5, 0xad, 0x31, 0x40, 0xd8, 0x86, 0x11, 0x82, 0xc6, 0xc1, 0x64, 0xb8, 0x3f,
	0xea, 0x6b, 0xbd, 0xfe, 0xab, 0xce, 0xfe, 0x50, 0x95, 0x04, 0xd4, 0x04, 0x89, 0xf3, 0xd4, 0xc9,
	0x68, 0x67, 0xaa, 0x4e, 0xc6, 0x7d, 0x49, 0x44, 0x9b, 0x80, 0x38, 0xf7, 0xbd, 0xd6, 0xeb, 0x0f,
	0xfb, 0x6a, 0x5f, 0xeb, 0xa8, 0x52, 0x6e, 0x4b, 0xf1, 0x6f, 0x23, 0xcc, 0xe1, 0x1a, 0x54, 0xa6,
	0x6a, 0x47, 0xed, 0x6b, 0xca, 0x3b, 0x49, 0x40, 0x2d, 0x68, 0x32, 0xaa, 0x3b, 0x19, 0xed, 0x75,
	0xba, 0xea, 0xee, 0x64, 0xac, 0x4d, 0x95, 0xae, 0x24, 0xa2, 0x3b, 0x70, 0x2b, 0xb5, 0xa2, 0x76,
	0x94, 0x41, 0x5f, 0x95, 0x72, 0x8f, 0xff, 0xaa, 0x41, 0xf9, 0x95, 0x61, 0xe2, 0xd1, 0xb1, 0x83,
	0xba, 0xd0, 0x50, 0xf0, 0xb1, 0xe1, 0x12, 0xec, 0xf0, 0xeb, 0x4a, 0x98, 0xde, 0xd8, 0x4c, 0x6a,
	0xdf, 0x4a, 0xf3, 0x59, 0xcb, 0x11, 0xd0, 0x73, 0x90, 0xf6, 0x2d, 0x27, 0xae, 0x26, 0xd9, 0xae,
	0xe9, 0x09, 0x69, 0x37, 0x02, 0x2e, 0xab, 0x42, 0x21, 0x0a, 0x80, 0x1f, 0xbe, 0x18, 0x80, 0xb0,
	0xb1, 0xc4, 0x01, 0x44, 0x7b, 0x9e, 0x80, 0x76, 0xa2, 0x00, 0xb8, 0x9a, 0x1b, 0x89, 0xc3, 0xe4,
	0xf5, 0x80, 0x88, 0x8e, 0x44, 0xef, 0x17, 0xd0, 0x0b, 0xa8, 0xb1, 0xde, 0x92, 0xda, 0x1f, 0xb6,
	0x9c, 0x76, 0x33, 0xc1, 0xf4, 0x37, 0x77, 0xa0, 0x1e, 0x36, 0xb2, 0x9e, 0xe1, 0xa0, 0x9b, 0x09,
	0xeb, 0xec, 0xdc, 0xae, 0xb3, 0xff, 0x0c, 0xa4, 0x50, 0xc5, 0x3a, 0x1f, 0xd2, 0x31, 0x7c, 0x01,
	0x68, 0xdf, 0xfa, 0xf8, 0x89, 0x9b, 0x87, 0xb1, 0xe6, 0xb4, 0xb3, 0xe2, 0x1d, 0xe6, 0x02, 0x07,
	0xee, 0x06, 0xec, 0x8c, 0x8e, 0x46, 0xa1, 0x54, 0x23, 0x17, 0x35, 0xd4, 0x0a, 0xc5, 0xe3, 0xd7,
	0xb7, 0xb6, 0x94, 0xa8, 0x0f, 0x57, 0x16, 0xd0, 0x13, 0xd8, 0x18, 0x60, 0xb2, 0xb6, 0x80, 0x92,
	0x37, 0x2e, 0x59, 0x40, 0x3d, 0xf6, 0x86, 0x08, 0x9f, 0x36, 0xe8, 0x4e, 0xcc, 0x6a, 0xfc, 0xcd,
	0xd3, 0x0e, 0xc3, 0x12, 0x3e, 0x05, 0x68, 0x09, 0xd5, 0x63, 0xc2, 0xa8, 0x9d, 0xad, 0x64, 0x9d,
	0x8e, 0x1f, 0x01, 0xc2, 0xd7, 0x0c, 0xba, 0x15, 0x53, 0x10, 0x3e, 0x71, 0x2e, 0xda, 0xfd, 0x16,
	0x36, 0x63, 0x96, 0x14, 0xfc, 0x61, 0xe1, 0xb8, 0xc6, 0x12, 0xaf, 0x85, 0x72, 0x3b, 0x58, 0x4b,
	0xb6, 0x6f, 0x9a, 0x5b, 0xaa, 0x32, 0x7a, 0x23, 0x78, 0xad, 0xbb, 0x27, 0xd8, 0x45, 0x89, 0x3a,
	0x68, 0x7f, 0x11, 0xd0, 0x99, 0xd7, 0x07, 0x59, 0x78, 0x24, 0xa2, 0x11, 0x34, 0xb3, 0xb4, 0x7d,
	0x6a, 0xa9, 0x3c, 0x05, 0x08, 0x17, 0xa2, 0xd1, 0x8a, 0xdd, 0x27, 0xda, 0xc9, 0xa1, 0x28, 0x0b,
	0xe8, 0x35, 0xd4, 0x63, 0x4f, 0x95, 0x48, 0x80, 0x52, 0x4f, 0x98, 0x48, 0x80, 0x92, 0x17, 0x72,
	0x59, 0x40, 0x3f, 0x40, 0xc5, 0x9f, 0x82, 0x11, 0x37, 0xa2, 0x83, 0x31, 0x52, 0xa8, 0x7c, 0x5e,
	0xc8, 0x02, 0x7a, 0x99, 0x38, 0x33, 0x57, 0x2c, 0x59, 0xdf, 0x81, 0x47, 0x22, 0xfa, 0x09, 0xae,
	0xef, 0xcf, 0x8f, 0x74, 0x82, 0xa3, 0xdd, 0x3d, 0xa3, 0xc5, 0xd2, 0x85, 0x8c, 0x53, 0xfb, 0x08,
	0x60, 0x8a, 0x89, 0x3f, 0x07, 0x23, 0x18, 0x97, 0x6b, 0x76, 0x0c, 0xc2, 0x1d, 0xc9, 0xfc, 0xa7,
	0x34, 0xc8, 0xc2, 0x61, 0x89, 0xfe, 0x87, 0xf0, 0xfd, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xee,
	0xf4, 0xe7, 0x41, 0x51, 0x10, 0x00, 0x00,
}
