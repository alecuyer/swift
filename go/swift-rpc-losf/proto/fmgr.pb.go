// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fmgr.proto

/*
Package filemgr is a generated protocol buffer package.

It is generated from these files:
	fmgr.proto

It has these top-level messages:
	ListPartitionsInfo
	ListPartitionInfo
	ListSuffixInfo
	DirEntries
	ListQuarantinedOHashesInfo
	QuarantinedObjects
	DataFileIndex
	DataFile
	GetNextOffsetInfo
	ListDataFilesInfo
	DataFiles
	DataFileNextOffset
	NewDataFileInfo
	NewDataFileState
	NewDataFileReply
	DelObjectReply
	RenameReply
	NewObjectInfo
	NewObjectReply
	UnregisterObjectInfo
	ObjectName
	LoadObjectInfo
	RenameInfo
	Object
	LoadObjectsResponse
	ObjectPrefix
	Empty
	GetStatsInfo
	PartitionContent
	FullPathEntry
	KvState
	KVStats
*/
package filemgr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// DataFile type
type DataFileType int32

const (
	DataFileType_VOLUME_DEFAULT     DataFileType = 0
	DataFileType_VOLUME_TOMBSTONE   DataFileType = 1
	DataFileType_VOLUME_X_DELETE_AT DataFileType = 2
)

var DataFileType_name = map[int32]string{
	0: "VOLUME_DEFAULT",
	1: "VOLUME_TOMBSTONE",
	2: "VOLUME_X_DELETE_AT",
}
var DataFileType_value = map[string]int32{
	"VOLUME_DEFAULT":     0,
	"VOLUME_TOMBSTONE":   1,
	"VOLUME_X_DELETE_AT": 2,
}

func (x DataFileType) String() string {
	return proto.EnumName(DataFileType_name, int32(x))
}
func (DataFileType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// DataFile state
type DataFileState int32

const (
	// Default state, volume can be read from and written to
	DataFileState_STATE_RW DataFileState = 0
	// Volume is being compacted (source). New objects cannot be appended
	DataFileState_STATE_COMPACTION_SRC DataFileState = 1
	// Volume is a compaction target. New objects cannot be appended
	DataFileState_STATE_COMPACTION_TARGET DataFileState = 2
)

var DataFileState_name = map[int32]string{
	0: "STATE_RW",
	1: "STATE_COMPACTION_SRC",
	2: "STATE_COMPACTION_TARGET",
}
var DataFileState_value = map[string]int32{
	"STATE_RW":                0,
	"STATE_COMPACTION_SRC":    1,
	"STATE_COMPACTION_TARGET": 2,
}

func (x DataFileState) String() string {
	return proto.EnumName(DataFileState_name, int32(x))
}
func (DataFileState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ListPartitionsInfo struct {
	PartitionBits uint32 `protobuf:"varint,1,opt,name=partition_bits,json=partitionBits" json:"partition_bits,omitempty"`
}

func (m *ListPartitionsInfo) Reset()                    { *m = ListPartitionsInfo{} }
func (m *ListPartitionsInfo) String() string            { return proto.CompactTextString(m) }
func (*ListPartitionsInfo) ProtoMessage()               {}
func (*ListPartitionsInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ListPartitionsInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

type ListPartitionInfo struct {
	Partition     uint32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	PartitionBits uint32 `protobuf:"varint,2,opt,name=partition_bits,json=partitionBits" json:"partition_bits,omitempty"`
}

func (m *ListPartitionInfo) Reset()                    { *m = ListPartitionInfo{} }
func (m *ListPartitionInfo) String() string            { return proto.CompactTextString(m) }
func (*ListPartitionInfo) ProtoMessage()               {}
func (*ListPartitionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListPartitionInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListPartitionInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

type ListSuffixInfo struct {
	Partition     uint32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	Suffix        []byte `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	PartitionBits uint32 `protobuf:"varint,3,opt,name=partition_bits,json=partitionBits" json:"partition_bits,omitempty"`
}

func (m *ListSuffixInfo) Reset()                    { *m = ListSuffixInfo{} }
func (m *ListSuffixInfo) String() string            { return proto.CompactTextString(m) }
func (*ListSuffixInfo) ProtoMessage()               {}
func (*ListSuffixInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListSuffixInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListSuffixInfo) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *ListSuffixInfo) GetPartitionBits() uint32 {
	if m != nil {
		return m.PartitionBits
	}
	return 0
}

// Generic reply message for List* functions (listdir like)
type DirEntries struct {
	Entry []string `protobuf:"bytes,1,rep,name=entry" json:"entry,omitempty"`
}

func (m *DirEntries) Reset()                    { *m = DirEntries{} }
func (m *DirEntries) String() string            { return proto.CompactTextString(m) }
func (*DirEntries) ProtoMessage()               {}
func (*DirEntries) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DirEntries) GetEntry() []string {
	if m != nil {
		return m.Entry
	}
	return nil
}

type ListQuarantinedOHashesInfo struct {
	// The entry from which to start. If it doesn't exist, will start from the next one in order, if any.
	// If an empty string is passed, start from the beginning
	FromEntry []byte `protobuf:"bytes,1,opt,name=from_entry,json=fromEntry,proto3" json:"from_entry,omitempty"`
}

func (m *ListQuarantinedOHashesInfo) Reset()                    { *m = ListQuarantinedOHashesInfo{} }
func (m *ListQuarantinedOHashesInfo) String() string            { return proto.CompactTextString(m) }
func (*ListQuarantinedOHashesInfo) ProtoMessage()               {}
func (*ListQuarantinedOHashesInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ListQuarantinedOHashesInfo) GetFromEntry() []byte {
	if m != nil {
		return m.FromEntry
	}
	return nil
}

type QuarantinedObjects struct {
	Entry     []string `protobuf:"bytes,1,rep,name=entry" json:"entry,omitempty"`
	LastEntry string   `protobuf:"bytes,2,opt,name=last_entry,json=lastEntry" json:"last_entry,omitempty"`
}

func (m *QuarantinedObjects) Reset()                    { *m = QuarantinedObjects{} }
func (m *QuarantinedObjects) String() string            { return proto.CompactTextString(m) }
func (*QuarantinedObjects) ProtoMessage()               {}
func (*QuarantinedObjects) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *QuarantinedObjects) GetEntry() []string {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *QuarantinedObjects) GetLastEntry() string {
	if m != nil {
		return m.LastEntry
	}
	return ""
}

// Datafile index
type DataFileIndex struct {
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,3,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *DataFileIndex) Reset()                    { *m = DataFileIndex{} }
func (m *DataFileIndex) String() string            { return proto.CompactTextString(m) }
func (*DataFileIndex) ProtoMessage()               {}
func (*DataFileIndex) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DataFileIndex) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *DataFileIndex) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// Datafile
type DataFile struct {
	DatafileIndex uint32 `protobuf:"varint,1,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	DatafileType  uint32 `protobuf:"varint,2,opt,name=datafile_type,json=datafileType" json:"datafile_type,omitempty"`
	DatafileState uint32 `protobuf:"varint,3,opt,name=datafile_state,json=datafileState" json:"datafile_state,omitempty"`
	Partition     uint32 `protobuf:"varint,4,opt,name=partition" json:"partition,omitempty"`
	NextOffset    uint64 `protobuf:"varint,5,opt,name=next_offset,json=nextOffset" json:"next_offset,omitempty"`
}

func (m *DataFile) Reset()                    { *m = DataFile{} }
func (m *DataFile) String() string            { return proto.CompactTextString(m) }
func (*DataFile) ProtoMessage()               {}
func (*DataFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DataFile) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *DataFile) GetDatafileType() uint32 {
	if m != nil {
		return m.DatafileType
	}
	return 0
}

func (m *DataFile) GetDatafileState() uint32 {
	if m != nil {
		return m.DatafileState
	}
	return 0
}

func (m *DataFile) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *DataFile) GetNextOffset() uint64 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

// Similar to datafile but we don't want to require the
// partition
type GetNextOffsetInfo struct {
	DatafileIndex uint32 `protobuf:"varint,1,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	DatafileType  uint32 `protobuf:"varint,2,opt,name=datafile_type,json=datafileType" json:"datafile_type,omitempty"`
	DatafileState uint32 `protobuf:"varint,3,opt,name=datafile_state,json=datafileState" json:"datafile_state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,4,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *GetNextOffsetInfo) Reset()                    { *m = GetNextOffsetInfo{} }
func (m *GetNextOffsetInfo) String() string            { return proto.CompactTextString(m) }
func (*GetNextOffsetInfo) ProtoMessage()               {}
func (*GetNextOffsetInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetNextOffsetInfo) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *GetNextOffsetInfo) GetDatafileType() uint32 {
	if m != nil {
		return m.DatafileType
	}
	return 0
}

func (m *GetNextOffsetInfo) GetDatafileState() uint32 {
	if m != nil {
		return m.DatafileState
	}
	return 0
}

func (m *GetNextOffsetInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type ListDataFilesInfo struct {
	Partition uint32       `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	Type      DataFileType `protobuf:"varint,2,opt,name=type,enum=filemgr.DataFileType" json:"type,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,3,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *ListDataFilesInfo) Reset()                    { *m = ListDataFilesInfo{} }
func (m *ListDataFilesInfo) String() string            { return proto.CompactTextString(m) }
func (*ListDataFilesInfo) ProtoMessage()               {}
func (*ListDataFilesInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListDataFilesInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ListDataFilesInfo) GetType() DataFileType {
	if m != nil {
		return m.Type
	}
	return DataFileType_VOLUME_DEFAULT
}

func (m *ListDataFilesInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type DataFiles struct {
	Datafiles []*DataFile `protobuf:"bytes,1,rep,name=datafiles" json:"datafiles,omitempty"`
}

func (m *DataFiles) Reset()                    { *m = DataFiles{} }
func (m *DataFiles) String() string            { return proto.CompactTextString(m) }
func (*DataFiles) ProtoMessage()               {}
func (*DataFiles) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DataFiles) GetDatafiles() []*DataFile {
	if m != nil {
		return m.Datafiles
	}
	return nil
}

// The response message to GetNextOffset
type DataFileNextOffset struct {
	Offset uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
}

func (m *DataFileNextOffset) Reset()                    { *m = DataFileNextOffset{} }
func (m *DataFileNextOffset) String() string            { return proto.CompactTextString(m) }
func (*DataFileNextOffset) ProtoMessage()               {}
func (*DataFileNextOffset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DataFileNextOffset) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// The request message for a new datafile
type NewDataFileInfo struct {
	// Swift partition
	Partition uint32       `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	Type      DataFileType `protobuf:"varint,2,opt,name=type,enum=filemgr.DataFileType" json:"type,omitempty"`
	// Index number of the datafile. It is up to the client to map this to an actual filename.
	DatafileIndex uint32 `protobuf:"varint,3,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	// Next available offset to use in the datafile.
	Offset uint64        `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
	State  DataFileState `protobuf:"varint,5,opt,name=state,enum=filemgr.DataFileState" json:"state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,6,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *NewDataFileInfo) Reset()                    { *m = NewDataFileInfo{} }
func (m *NewDataFileInfo) String() string            { return proto.CompactTextString(m) }
func (*NewDataFileInfo) ProtoMessage()               {}
func (*NewDataFileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *NewDataFileInfo) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *NewDataFileInfo) GetType() DataFileType {
	if m != nil {
		return m.Type
	}
	return DataFileType_VOLUME_DEFAULT
}

func (m *NewDataFileInfo) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *NewDataFileInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *NewDataFileInfo) GetState() DataFileState {
	if m != nil {
		return m.State
	}
	return DataFileState_STATE_RW
}

func (m *NewDataFileInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type NewDataFileState struct {
	DatafileIndex uint32        `protobuf:"varint,1,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	State         DataFileState `protobuf:"varint,2,opt,name=state,enum=filemgr.DataFileState" json:"state,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,3,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *NewDataFileState) Reset()                    { *m = NewDataFileState{} }
func (m *NewDataFileState) String() string            { return proto.CompactTextString(m) }
func (*NewDataFileState) ProtoMessage()               {}
func (*NewDataFileState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NewDataFileState) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *NewDataFileState) GetState() DataFileState {
	if m != nil {
		return m.State
	}
	return DataFileState_STATE_RW
}

func (m *NewDataFileState) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The response message for a new datafile
type NewDataFileReply struct {
}

func (m *NewDataFileReply) Reset()                    { *m = NewDataFileReply{} }
func (m *NewDataFileReply) String() string            { return proto.CompactTextString(m) }
func (*NewDataFileReply) ProtoMessage()               {}
func (*NewDataFileReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type DelObjectReply struct {
}

func (m *DelObjectReply) Reset()                    { *m = DelObjectReply{} }
func (m *DelObjectReply) String() string            { return proto.CompactTextString(m) }
func (*DelObjectReply) ProtoMessage()               {}
func (*DelObjectReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type RenameReply struct {
}

func (m *RenameReply) Reset()                    { *m = RenameReply{} }
func (m *RenameReply) String() string            { return proto.CompactTextString(m) }
func (*RenameReply) ProtoMessage()               {}
func (*RenameReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// The request message for a new object
type NewObjectInfo struct {
	// Object "name". Name made of (md5, timestamp, etc..)
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Index number of the datafile.
	DatafileIndex uint32 `protobuf:"varint,2,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	// Start offset of the object in the datafile.
	Offset uint64 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	// Next available offset to use in the datafile.
	NextOffset uint64 `protobuf:"varint,4,opt,name=next_offset,json=nextOffset" json:"next_offset,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,5,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *NewObjectInfo) Reset()                    { *m = NewObjectInfo{} }
func (m *NewObjectInfo) String() string            { return proto.CompactTextString(m) }
func (*NewObjectInfo) ProtoMessage()               {}
func (*NewObjectInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *NewObjectInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NewObjectInfo) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *NewObjectInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *NewObjectInfo) GetNextOffset() uint64 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

func (m *NewObjectInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The response message for a new object
// Currently empty, but we may want to return something in the future
type NewObjectReply struct {
}

func (m *NewObjectReply) Reset()                    { *m = NewObjectReply{} }
func (m *NewObjectReply) String() string            { return proto.CompactTextString(m) }
func (*NewObjectReply) ProtoMessage()               {}
func (*NewObjectReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

// Debug message to unregister an object (ObjectName would suffice otherwise)
type UnregisterObjectInfo struct {
	Name          []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DatafileIndex uint32 `protobuf:"varint,2,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	Offset        uint64 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Length        uint64 `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
}

func (m *UnregisterObjectInfo) Reset()                    { *m = UnregisterObjectInfo{} }
func (m *UnregisterObjectInfo) String() string            { return proto.CompactTextString(m) }
func (*UnregisterObjectInfo) ProtoMessage()               {}
func (*UnregisterObjectInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *UnregisterObjectInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *UnregisterObjectInfo) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *UnregisterObjectInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *UnregisterObjectInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type ObjectName struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,2,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *ObjectName) Reset()                    { *m = ObjectName{} }
func (m *ObjectName) String() string            { return proto.CompactTextString(m) }
func (*ObjectName) ProtoMessage()               {}
func (*ObjectName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ObjectName) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *ObjectName) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type LoadObjectInfo struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Is it quarantined ?
	IsQuarantined bool `protobuf:"varint,2,opt,name=is_quarantined,json=isQuarantined" json:"is_quarantined,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,3,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *LoadObjectInfo) Reset()                    { *m = LoadObjectInfo{} }
func (m *LoadObjectInfo) String() string            { return proto.CompactTextString(m) }
func (*LoadObjectInfo) ProtoMessage()               {}
func (*LoadObjectInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *LoadObjectInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *LoadObjectInfo) GetIsQuarantined() bool {
	if m != nil {
		return m.IsQuarantined
	}
	return false
}

func (m *LoadObjectInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

// The request message to rename an object
type RenameInfo struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// new name of the object
	NewName []byte `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,3,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *RenameInfo) Reset()                    { *m = RenameInfo{} }
func (m *RenameInfo) String() string            { return proto.CompactTextString(m) }
func (*RenameInfo) ProtoMessage()               {}
func (*RenameInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *RenameInfo) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *RenameInfo) GetNewName() []byte {
	if m != nil {
		return m.NewName
	}
	return nil
}

func (m *RenameInfo) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Object struct {
	// name of the object.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Index number of the datafile.
	DatafileIndex uint32 `protobuf:"varint,2,opt,name=datafile_index,json=datafileIndex" json:"datafile_index,omitempty"`
	// Start offset of the object in the datafile.
	Offset uint64 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Object) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Object) GetDatafileIndex() uint32 {
	if m != nil {
		return m.DatafileIndex
	}
	return 0
}

func (m *Object) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type LoadObjectsResponse struct {
	Objects []*Object `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
}

func (m *LoadObjectsResponse) Reset()                    { *m = LoadObjectsResponse{} }
func (m *LoadObjectsResponse) String() string            { return proto.CompactTextString(m) }
func (*LoadObjectsResponse) ProtoMessage()               {}
func (*LoadObjectsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *LoadObjectsResponse) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

type ObjectPrefix struct {
	Prefix []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Is this request coming from a repair tool ?
	RepairTool bool `protobuf:"varint,2,opt,name=repair_tool,json=repairTool" json:"repair_tool,omitempty"`
}

func (m *ObjectPrefix) Reset()                    { *m = ObjectPrefix{} }
func (m *ObjectPrefix) String() string            { return proto.CompactTextString(m) }
func (*ObjectPrefix) ProtoMessage()               {}
func (*ObjectPrefix) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ObjectPrefix) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ObjectPrefix) GetRepairTool() bool {
	if m != nil {
		return m.RepairTool
	}
	return false
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type GetStatsInfo struct {
}

func (m *GetStatsInfo) Reset()                    { *m = GetStatsInfo{} }
func (m *GetStatsInfo) String() string            { return proto.CompactTextString(m) }
func (*GetStatsInfo) ProtoMessage()               {}
func (*GetStatsInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type PartitionContent struct {
	FileEntries []*FullPathEntry `protobuf:"bytes,1,rep,name=file_entries,json=fileEntries" json:"file_entries,omitempty"`
}

func (m *PartitionContent) Reset()                    { *m = PartitionContent{} }
func (m *PartitionContent) String() string            { return proto.CompactTextString(m) }
func (*PartitionContent) ProtoMessage()               {}
func (*PartitionContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *PartitionContent) GetFileEntries() []*FullPathEntry {
	if m != nil {
		return m.FileEntries
	}
	return nil
}

type FullPathEntry struct {
	// We could add the partition if needed
	Suffix   []byte `protobuf:"bytes,1,opt,name=suffix,proto3" json:"suffix,omitempty"`
	Ohash    []byte `protobuf:"bytes,2,opt,name=ohash,proto3" json:"ohash,omitempty"`
	Filename []byte `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (m *FullPathEntry) Reset()                    { *m = FullPathEntry{} }
func (m *FullPathEntry) String() string            { return proto.CompactTextString(m) }
func (*FullPathEntry) ProtoMessage()               {}
func (*FullPathEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *FullPathEntry) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *FullPathEntry) GetOhash() []byte {
	if m != nil {
		return m.Ohash
	}
	return nil
}

func (m *FullPathEntry) GetFilename() []byte {
	if m != nil {
		return m.Filename
	}
	return nil
}

type KvState struct {
	IsClean bool `protobuf:"varint,1,opt,name=isClean" json:"isClean,omitempty"`
}

func (m *KvState) Reset()                    { *m = KvState{} }
func (m *KvState) String() string            { return proto.CompactTextString(m) }
func (*KvState) ProtoMessage()               {}
func (*KvState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *KvState) GetIsClean() bool {
	if m != nil {
		return m.IsClean
	}
	return false
}

// KV stats
type KVStats struct {
	Stats map[string]uint64 `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *KVStats) Reset()                    { *m = KVStats{} }
func (m *KVStats) String() string            { return proto.CompactTextString(m) }
func (*KVStats) ProtoMessage()               {}
func (*KVStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *KVStats) GetStats() map[string]uint64 {
	if m != nil {
		return m.Stats
	}
	return nil
}

func init() {
	proto.RegisterType((*ListPartitionsInfo)(nil), "filemgr.ListPartitionsInfo")
	proto.RegisterType((*ListPartitionInfo)(nil), "filemgr.ListPartitionInfo")
	proto.RegisterType((*ListSuffixInfo)(nil), "filemgr.ListSuffixInfo")
	proto.RegisterType((*DirEntries)(nil), "filemgr.DirEntries")
	proto.RegisterType((*ListQuarantinedOHashesInfo)(nil), "filemgr.ListQuarantinedOHashesInfo")
	proto.RegisterType((*QuarantinedObjects)(nil), "filemgr.QuarantinedObjects")
	proto.RegisterType((*DataFileIndex)(nil), "filemgr.DataFileIndex")
	proto.RegisterType((*DataFile)(nil), "filemgr.DataFile")
	proto.RegisterType((*GetNextOffsetInfo)(nil), "filemgr.GetNextOffsetInfo")
	proto.RegisterType((*ListDataFilesInfo)(nil), "filemgr.ListDataFilesInfo")
	proto.RegisterType((*DataFiles)(nil), "filemgr.DataFiles")
	proto.RegisterType((*DataFileNextOffset)(nil), "filemgr.DataFileNextOffset")
	proto.RegisterType((*NewDataFileInfo)(nil), "filemgr.NewDataFileInfo")
	proto.RegisterType((*NewDataFileState)(nil), "filemgr.NewDataFileState")
	proto.RegisterType((*NewDataFileReply)(nil), "filemgr.NewDataFileReply")
	proto.RegisterType((*DelObjectReply)(nil), "filemgr.DelObjectReply")
	proto.RegisterType((*RenameReply)(nil), "filemgr.RenameReply")
	proto.RegisterType((*NewObjectInfo)(nil), "filemgr.NewObjectInfo")
	proto.RegisterType((*NewObjectReply)(nil), "filemgr.NewObjectReply")
	proto.RegisterType((*UnregisterObjectInfo)(nil), "filemgr.UnregisterObjectInfo")
	proto.RegisterType((*ObjectName)(nil), "filemgr.ObjectName")
	proto.RegisterType((*LoadObjectInfo)(nil), "filemgr.LoadObjectInfo")
	proto.RegisterType((*RenameInfo)(nil), "filemgr.RenameInfo")
	proto.RegisterType((*Object)(nil), "filemgr.Object")
	proto.RegisterType((*LoadObjectsResponse)(nil), "filemgr.LoadObjectsResponse")
	proto.RegisterType((*ObjectPrefix)(nil), "filemgr.ObjectPrefix")
	proto.RegisterType((*Empty)(nil), "filemgr.Empty")
	proto.RegisterType((*GetStatsInfo)(nil), "filemgr.GetStatsInfo")
	proto.RegisterType((*PartitionContent)(nil), "filemgr.PartitionContent")
	proto.RegisterType((*FullPathEntry)(nil), "filemgr.FullPathEntry")
	proto.RegisterType((*KvState)(nil), "filemgr.KvState")
	proto.RegisterType((*KVStats)(nil), "filemgr.KVStats")
	proto.RegisterEnum("filemgr.DataFileType", DataFileType_name, DataFileType_value)
	proto.RegisterEnum("filemgr.DataFileState", DataFileState_name, DataFileState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FileMgr service

type FileMgrClient interface {
	// Register a new DataFile
	RegisterDataFile(ctx context.Context, in *NewDataFileInfo, opts ...grpc.CallOption) (*NewDataFileReply, error)
	// Unregister a DataFile
	UnregisterDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (*Empty, error)
	// Register a new object
	RegisterObject(ctx context.Context, in *NewObjectInfo, opts ...grpc.CallOption) (*NewObjectReply, error)
	// Unregister an object
	UnregisterObject(ctx context.Context, in *UnregisterObjectInfo, opts ...grpc.CallOption) (*DelObjectReply, error)
	// Rename an object
	RenameObject(ctx context.Context, in *RenameInfo, opts ...grpc.CallOption) (*RenameReply, error)
	// Quarantine a "directory" (all objects "below" ohash)
	// DEPRECATED
	QuarantineDir(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*DelObjectReply, error)
	// Quarantine an object
	QuarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error)
	// Unquarantine an object
	UnquarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error)
	// Get array of object locations
	LoadObjectsByPrefix(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error)
	// List DataFiles
	ListDataFiles(ctx context.Context, in *ListDataFilesInfo, opts ...grpc.CallOption) (*DataFiles, error)
	// Get DataFile by index
	GetDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (*DataFile, error)
	// List partitions
	ListPartitions(ctx context.Context, in *ListPartitionsInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// List suffixes within partition
	ListPartition(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// List object hashes within partition/suffix
	ListSuffix(ctx context.Context, in *ListSuffixInfo, opts ...grpc.CallOption) (*DirEntries, error)
	// Recursively list the partition content, down to files
	ListPartitionRecursive(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*PartitionContent, error)
	// List quarantined objects. Because this may be large, and we can't use a stream, it uses a cursor
	ListQuarantinedOHashes(ctx context.Context, in *ListQuarantinedOHashesInfo, opts ...grpc.CallOption) (*QuarantinedObjects, error)
	// List files within a quarantined object (ohash)
	ListQuarantinedOHash(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error)
	// Get object
	LoadObject(ctx context.Context, in *LoadObjectInfo, opts ...grpc.CallOption) (*Object, error)
	// Get next offset to write to in a datafile
	GetNextOffset(ctx context.Context, in *GetNextOffsetInfo, opts ...grpc.CallOption) (*DataFileNextOffset, error)
	// Get KVStats
	GetStats(ctx context.Context, in *GetStatsInfo, opts ...grpc.CallOption) (*KVStats, error)
	// List objects per volume - used for compaction (no eventlet, ok to use stream)
	LoadObjectsByDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (FileMgr_LoadObjectsByDataFileClient, error)
	// Update DataFile state
	UpdateDataFileState(ctx context.Context, in *NewDataFileState, opts ...grpc.CallOption) (*Empty, error)
	// Set state (clean: in sync with the volumes)
	SetKvState(ctx context.Context, in *KvState, opts ...grpc.CallOption) (*Empty, error)
	// Get state (clean: in sync with the volumes)
	GetKvState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KvState, error)
}

type fileMgrClient struct {
	cc *grpc.ClientConn
}

func NewFileMgrClient(cc *grpc.ClientConn) FileMgrClient {
	return &fileMgrClient{cc}
}

func (c *fileMgrClient) RegisterDataFile(ctx context.Context, in *NewDataFileInfo, opts ...grpc.CallOption) (*NewDataFileReply, error) {
	out := new(NewDataFileReply)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/RegisterDataFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnregisterDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/UnregisterDataFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) RegisterObject(ctx context.Context, in *NewObjectInfo, opts ...grpc.CallOption) (*NewObjectReply, error) {
	out := new(NewObjectReply)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/RegisterObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnregisterObject(ctx context.Context, in *UnregisterObjectInfo, opts ...grpc.CallOption) (*DelObjectReply, error) {
	out := new(DelObjectReply)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/UnregisterObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) RenameObject(ctx context.Context, in *RenameInfo, opts ...grpc.CallOption) (*RenameReply, error) {
	out := new(RenameReply)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/RenameObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) QuarantineDir(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*DelObjectReply, error) {
	out := new(DelObjectReply)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/QuarantineDir", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) QuarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/QuarantineObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) UnquarantineObject(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/UnquarantineObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObjectsByPrefix(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error) {
	out := new(LoadObjectsResponse)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/LoadObjectsByPrefix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListDataFiles(ctx context.Context, in *ListDataFilesInfo, opts ...grpc.CallOption) (*DataFiles, error) {
	out := new(DataFiles)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListDataFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (*DataFile, error) {
	out := new(DataFile)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/GetDataFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartitions(ctx context.Context, in *ListPartitionsInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListPartitions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartition(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListPartition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListSuffix(ctx context.Context, in *ListSuffixInfo, opts ...grpc.CallOption) (*DirEntries, error) {
	out := new(DirEntries)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListSuffix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListPartitionRecursive(ctx context.Context, in *ListPartitionInfo, opts ...grpc.CallOption) (*PartitionContent, error) {
	out := new(PartitionContent)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListPartitionRecursive", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListQuarantinedOHashes(ctx context.Context, in *ListQuarantinedOHashesInfo, opts ...grpc.CallOption) (*QuarantinedObjects, error) {
	out := new(QuarantinedObjects)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListQuarantinedOHashes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) ListQuarantinedOHash(ctx context.Context, in *ObjectPrefix, opts ...grpc.CallOption) (*LoadObjectsResponse, error) {
	out := new(LoadObjectsResponse)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/ListQuarantinedOHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObject(ctx context.Context, in *LoadObjectInfo, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/LoadObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetNextOffset(ctx context.Context, in *GetNextOffsetInfo, opts ...grpc.CallOption) (*DataFileNextOffset, error) {
	out := new(DataFileNextOffset)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/GetNextOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetStats(ctx context.Context, in *GetStatsInfo, opts ...grpc.CallOption) (*KVStats, error) {
	out := new(KVStats)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/GetStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) LoadObjectsByDataFile(ctx context.Context, in *DataFileIndex, opts ...grpc.CallOption) (FileMgr_LoadObjectsByDataFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileMgr_serviceDesc.Streams[0], c.cc, "/filemgr.FileMgr/LoadObjectsByDataFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileMgrLoadObjectsByDataFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileMgr_LoadObjectsByDataFileClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type fileMgrLoadObjectsByDataFileClient struct {
	grpc.ClientStream
}

func (x *fileMgrLoadObjectsByDataFileClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileMgrClient) UpdateDataFileState(ctx context.Context, in *NewDataFileState, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/UpdateDataFileState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) SetKvState(ctx context.Context, in *KvState, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/SetKvState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) GetKvState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KvState, error) {
	out := new(KvState)
	err := grpc.Invoke(ctx, "/filemgr.FileMgr/GetKvState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileMgr service

type FileMgrServer interface {
	// Register a new DataFile
	RegisterDataFile(context.Context, *NewDataFileInfo) (*NewDataFileReply, error)
	// Unregister a DataFile
	UnregisterDataFile(context.Context, *DataFileIndex) (*Empty, error)
	// Register a new object
	RegisterObject(context.Context, *NewObjectInfo) (*NewObjectReply, error)
	// Unregister an object
	UnregisterObject(context.Context, *UnregisterObjectInfo) (*DelObjectReply, error)
	// Rename an object
	RenameObject(context.Context, *RenameInfo) (*RenameReply, error)
	// Quarantine a "directory" (all objects "below" ohash)
	// DEPRECATED
	QuarantineDir(context.Context, *ObjectPrefix) (*DelObjectReply, error)
	// Quarantine an object
	QuarantineObject(context.Context, *ObjectName) (*Empty, error)
	// Unquarantine an object
	UnquarantineObject(context.Context, *ObjectName) (*Empty, error)
	// Get array of object locations
	LoadObjectsByPrefix(context.Context, *ObjectPrefix) (*LoadObjectsResponse, error)
	// List DataFiles
	ListDataFiles(context.Context, *ListDataFilesInfo) (*DataFiles, error)
	// Get DataFile by index
	GetDataFile(context.Context, *DataFileIndex) (*DataFile, error)
	// List partitions
	ListPartitions(context.Context, *ListPartitionsInfo) (*DirEntries, error)
	// List suffixes within partition
	ListPartition(context.Context, *ListPartitionInfo) (*DirEntries, error)
	// List object hashes within partition/suffix
	ListSuffix(context.Context, *ListSuffixInfo) (*DirEntries, error)
	// Recursively list the partition content, down to files
	ListPartitionRecursive(context.Context, *ListPartitionInfo) (*PartitionContent, error)
	// List quarantined objects. Because this may be large, and we can't use a stream, it uses a cursor
	ListQuarantinedOHashes(context.Context, *ListQuarantinedOHashesInfo) (*QuarantinedObjects, error)
	// List files within a quarantined object (ohash)
	ListQuarantinedOHash(context.Context, *ObjectPrefix) (*LoadObjectsResponse, error)
	// Get object
	LoadObject(context.Context, *LoadObjectInfo) (*Object, error)
	// Get next offset to write to in a datafile
	GetNextOffset(context.Context, *GetNextOffsetInfo) (*DataFileNextOffset, error)
	// Get KVStats
	GetStats(context.Context, *GetStatsInfo) (*KVStats, error)
	// List objects per volume - used for compaction (no eventlet, ok to use stream)
	LoadObjectsByDataFile(*DataFileIndex, FileMgr_LoadObjectsByDataFileServer) error
	// Update DataFile state
	UpdateDataFileState(context.Context, *NewDataFileState) (*Empty, error)
	// Set state (clean: in sync with the volumes)
	SetKvState(context.Context, *KvState) (*Empty, error)
	// Get state (clean: in sync with the volumes)
	GetKvState(context.Context, *Empty) (*KvState, error)
}

func RegisterFileMgrServer(s *grpc.Server, srv FileMgrServer) {
	s.RegisterService(&_FileMgr_serviceDesc, srv)
}

func _FileMgr_RegisterDataFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDataFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RegisterDataFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RegisterDataFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RegisterDataFile(ctx, req.(*NewDataFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnregisterDataFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataFileIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnregisterDataFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnregisterDataFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnregisterDataFile(ctx, req.(*DataFileIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_RegisterObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewObjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RegisterObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RegisterObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RegisterObject(ctx, req.(*NewObjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnregisterObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterObjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnregisterObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnregisterObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnregisterObject(ctx, req.(*UnregisterObjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_RenameObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).RenameObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/RenameObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).RenameObject(ctx, req.(*RenameInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_QuarantineDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).QuarantineDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/QuarantineDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).QuarantineDir(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_QuarantineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).QuarantineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/QuarantineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).QuarantineObject(ctx, req.(*ObjectName))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_UnquarantineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UnquarantineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UnquarantineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UnquarantineObject(ctx, req.(*ObjectName))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObjectsByPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).LoadObjectsByPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/LoadObjectsByPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).LoadObjectsByPrefix(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListDataFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDataFilesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListDataFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListDataFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListDataFiles(ctx, req.(*ListDataFilesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetDataFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataFileIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetDataFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetDataFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetDataFile(ctx, req.(*DataFileIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartitions(ctx, req.(*ListPartitionsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartition(ctx, req.(*ListPartitionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListSuffix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSuffixInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListSuffix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListSuffix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListSuffix(ctx, req.(*ListSuffixInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListPartitionRecursive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListPartitionRecursive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListPartitionRecursive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListPartitionRecursive(ctx, req.(*ListPartitionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListQuarantinedOHashes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListQuarantinedOHashesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListQuarantinedOHashes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListQuarantinedOHashes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListQuarantinedOHashes(ctx, req.(*ListQuarantinedOHashesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_ListQuarantinedOHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPrefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).ListQuarantinedOHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/ListQuarantinedOHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).ListQuarantinedOHash(ctx, req.(*ObjectPrefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadObjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).LoadObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/LoadObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).LoadObject(ctx, req.(*LoadObjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetNextOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextOffsetInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetNextOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetNextOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetNextOffset(ctx, req.(*GetNextOffsetInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetStats(ctx, req.(*GetStatsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_LoadObjectsByDataFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DataFileIndex)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileMgrServer).LoadObjectsByDataFile(m, &fileMgrLoadObjectsByDataFileServer{stream})
}

type FileMgr_LoadObjectsByDataFileServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type fileMgrLoadObjectsByDataFileServer struct {
	grpc.ServerStream
}

func (x *fileMgrLoadObjectsByDataFileServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func _FileMgr_UpdateDataFileState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDataFileState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).UpdateDataFileState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/UpdateDataFileState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).UpdateDataFileState(ctx, req.(*NewDataFileState))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_SetKvState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).SetKvState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/SetKvState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).SetKvState(ctx, req.(*KvState))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_GetKvState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).GetKvState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filemgr.FileMgr/GetKvState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).GetKvState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "filemgr.FileMgr",
	HandlerType: (*FileMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDataFile",
			Handler:    _FileMgr_RegisterDataFile_Handler,
		},
		{
			MethodName: "UnregisterDataFile",
			Handler:    _FileMgr_UnregisterDataFile_Handler,
		},
		{
			MethodName: "RegisterObject",
			Handler:    _FileMgr_RegisterObject_Handler,
		},
		{
			MethodName: "UnregisterObject",
			Handler:    _FileMgr_UnregisterObject_Handler,
		},
		{
			MethodName: "RenameObject",
			Handler:    _FileMgr_RenameObject_Handler,
		},
		{
			MethodName: "QuarantineDir",
			Handler:    _FileMgr_QuarantineDir_Handler,
		},
		{
			MethodName: "QuarantineObject",
			Handler:    _FileMgr_QuarantineObject_Handler,
		},
		{
			MethodName: "UnquarantineObject",
			Handler:    _FileMgr_UnquarantineObject_Handler,
		},
		{
			MethodName: "LoadObjectsByPrefix",
			Handler:    _FileMgr_LoadObjectsByPrefix_Handler,
		},
		{
			MethodName: "ListDataFiles",
			Handler:    _FileMgr_ListDataFiles_Handler,
		},
		{
			MethodName: "GetDataFile",
			Handler:    _FileMgr_GetDataFile_Handler,
		},
		{
			MethodName: "ListPartitions",
			Handler:    _FileMgr_ListPartitions_Handler,
		},
		{
			MethodName: "ListPartition",
			Handler:    _FileMgr_ListPartition_Handler,
		},
		{
			MethodName: "ListSuffix",
			Handler:    _FileMgr_ListSuffix_Handler,
		},
		{
			MethodName: "ListPartitionRecursive",
			Handler:    _FileMgr_ListPartitionRecursive_Handler,
		},
		{
			MethodName: "ListQuarantinedOHashes",
			Handler:    _FileMgr_ListQuarantinedOHashes_Handler,
		},
		{
			MethodName: "ListQuarantinedOHash",
			Handler:    _FileMgr_ListQuarantinedOHash_Handler,
		},
		{
			MethodName: "LoadObject",
			Handler:    _FileMgr_LoadObject_Handler,
		},
		{
			MethodName: "GetNextOffset",
			Handler:    _FileMgr_GetNextOffset_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _FileMgr_GetStats_Handler,
		},
		{
			MethodName: "UpdateDataFileState",
			Handler:    _FileMgr_UpdateDataFileState_Handler,
		},
		{
			MethodName: "SetKvState",
			Handler:    _FileMgr_SetKvState_Handler,
		},
		{
			MethodName: "GetKvState",
			Handler:    _FileMgr_GetKvState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LoadObjectsByDataFile",
			Handler:       _FileMgr_LoadObjectsByDataFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "fmgr.proto",
}

func init() { proto.RegisterFile("fmgr.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xdd, 0x6e, 0x13, 0x47,
	0x1b, 0xf6, 0x3a, 0x76, 0x6c, 0xbf, 0xb1, 0xcd, 0x32, 0x98, 0x10, 0x16, 0x10, 0x68, 0xd0, 0x27,
	0x01, 0x42, 0xf9, 0x28, 0x55, 0x25, 0x20, 0xa8, 0xaa, 0x13, 0x3b, 0x69, 0x8a, 0x63, 0x87, 0xcd,
	0x86, 0x52, 0x15, 0x69, 0xb5, 0x90, 0x71, 0xb2, 0xed, 0x66, 0xd7, 0xec, 0x4e, 0x12, 0x72, 0xd0,
	0x83, 0x9e, 0xf5, 0x42, 0x2a, 0xf5, 0x26, 0x7a, 0x2f, 0x3d, 0xed, 0x65, 0x54, 0xf3, 0xb3, 0x3b,
	0xfb, 0x97, 0x04, 0xa1, 0xd2, 0x13, 0x6b, 0xe7, 0x99, 0x99, 0xe7, 0xfd, 0x7f, 0x67, 0xc6, 0x00,
	0xd3, 0xc3, 0xfd, 0x70, 0x79, 0x16, 0x06, 0x34, 0x40, 0x8d, 0xa9, 0xeb, 0x91, 0xc3, 0xfd, 0x10,
	0xaf, 0x00, 0x1a, 0xb9, 0x11, 0xdd, 0x76, 0x42, 0xea, 0x52, 0x37, 0xf0, 0xa3, 0x4d, 0x7f, 0x1a,
	0xa0, 0xff, 0x41, 0x77, 0x16, 0x23, 0xf6, 0x5b, 0x97, 0x46, 0x4b, 0xda, 0x1d, 0xed, 0x5e, 0xc7,
	0xec, 0x24, 0xe8, 0xaa, 0x4b, 0x23, 0xfc, 0x1a, 0x2e, 0x67, 0x36, 0xf3, 0xbd, 0x37, 0xa1, 0x95,
	0xac, 0x92, 0xdb, 0x14, 0x50, 0xc2, 0x5c, 0x2d, 0x63, 0x3e, 0x84, 0x2e, 0x63, 0xde, 0x39, 0x9a,
	0x4e, 0xdd, 0x0f, 0x1f, 0x41, 0xbb, 0x08, 0xf3, 0x11, 0x5f, 0xcb, 0xe9, 0xda, 0xa6, 0x1c, 0x95,
	0x88, 0x9b, 0x2b, 0x13, 0x87, 0x01, 0x06, 0x6e, 0x38, 0xf4, 0x69, 0xe8, 0x92, 0x08, 0xf5, 0xa0,
	0x4e, 0x7c, 0x1a, 0x9e, 0x2e, 0x69, 0x77, 0xe6, 0xee, 0xb5, 0x4c, 0x31, 0xc0, 0x2b, 0x60, 0x30,
	0x95, 0x5e, 0x1e, 0x39, 0xa1, 0xe3, 0x53, 0xd7, 0x27, 0x7b, 0x93, 0x6f, 0x9d, 0xe8, 0x80, 0x08,
	0x8f, 0xdd, 0x02, 0x98, 0x86, 0xc1, 0xa1, 0x1d, 0x6f, 0x64, 0x4a, 0xb4, 0x18, 0x32, 0xe4, 0x9b,
	0x37, 0x01, 0xa5, 0x37, 0xbe, 0xfd, 0x89, 0xbc, 0xa3, 0x67, 0x08, 0x62, 0x54, 0x9e, 0x13, 0x51,
	0x49, 0xc5, 0xec, 0x69, 0x99, 0x2d, 0x86, 0x08, 0xaa, 0x75, 0xe8, 0x0c, 0x1c, 0xea, 0xac, 0xbb,
	0x1e, 0xd9, 0xf4, 0xf7, 0xc8, 0x07, 0xc6, 0xe2, 0xb2, 0x0f, 0xe9, 0x49, 0x31, 0x40, 0xb7, 0x61,
	0x21, 0x24, 0x33, 0xc7, 0x0d, 0x6d, 0x1a, 0x04, 0x1e, 0x37, 0xbb, 0x69, 0x82, 0x80, 0xac, 0x20,
	0xf0, 0xf0, 0x9f, 0x1a, 0x34, 0x63, 0x22, 0xe6, 0xa7, 0x3d, 0x87, 0x3a, 0x2c, 0x2b, 0x6c, 0x41,
	0x26, 0x03, 0x1e, 0xa3, 0x42, 0xd4, 0x5d, 0x48, 0x00, 0x9b, 0x9e, 0xce, 0x88, 0x14, 0xd9, 0x8e,
	0x41, 0xeb, 0x74, 0x96, 0xe5, 0x8a, 0xa8, 0x43, 0x49, 0xec, 0xf3, 0x18, 0xdd, 0x61, 0x60, 0x36,
	0xa0, 0xb5, 0x7c, 0x40, 0x6f, 0xc3, 0x82, 0x4f, 0x3e, 0x50, 0x3b, 0x98, 0x4e, 0x23, 0x42, 0x97,
	0xea, 0x77, 0xb4, 0x7b, 0x35, 0x13, 0x18, 0x34, 0xe1, 0x08, 0xfe, 0x43, 0x83, 0xcb, 0x1b, 0x84,
	0x8e, 0x13, 0x24, 0x4e, 0xdc, 0xff, 0xda, 0x8e, 0x9c, 0xa3, 0x6b, 0x05, 0x47, 0xff, 0x22, 0xaa,
	0x24, 0xf6, 0x75, 0xf4, 0x11, 0xe9, 0x7c, 0x1f, 0x6a, 0x89, 0x5a, 0xdd, 0xc7, 0x57, 0x97, 0x65,
	0xb5, 0x2e, 0xc7, 0x1c, 0x4c, 0x3f, 0x93, 0x2f, 0xb9, 0x38, 0xce, 0xcf, 0xa1, 0x95, 0x88, 0x46,
	0xff, 0x87, 0x56, 0xac, 0x7d, 0xc4, 0xb3, 0x6e, 0xe1, 0xf1, 0xe5, 0x02, 0xbb, 0xa9, 0xd6, 0xe0,
	0x87, 0x80, 0x62, 0x58, 0xb9, 0x9a, 0x95, 0x9b, 0x0c, 0x8c, 0xc6, 0x03, 0x23, 0x47, 0xf8, 0x6f,
	0x0d, 0x2e, 0x8d, 0xc9, 0x89, 0xca, 0xcf, 0x7f, 0xd3, 0xd2, 0x62, 0x6c, 0xe7, 0xca, 0x62, 0xab,
	0x74, 0xab, 0xa5, 0x75, 0x43, 0x0f, 0xa1, 0x2e, 0xa2, 0x58, 0xe7, 0xa2, 0x16, 0x0b, 0xa2, 0x78,
	0x38, 0x4d, 0xb1, 0x28, 0xef, 0xd6, 0xf9, 0x82, 0x5b, 0x7f, 0xd3, 0x40, 0x4f, 0x99, 0x2a, 0x72,
	0xe1, 0x23, 0xd3, 0x2f, 0x51, 0xa5, 0xfa, 0x09, 0xaa, 0x14, 0x23, 0x8c, 0x32, 0x9a, 0x98, 0x64,
	0xe6, 0x9d, 0x62, 0x1d, 0xba, 0x03, 0xe2, 0x89, 0x46, 0x23, 0x90, 0x0e, 0x2c, 0x98, 0xc4, 0x77,
	0x0e, 0xe5, 0x82, 0xdf, 0x35, 0xe8, 0x8c, 0xc9, 0x89, 0x58, 0xc1, 0x03, 0x85, 0xa0, 0xc6, 0xa6,
	0x65, 0xf3, 0xe2, 0xdf, 0x25, 0x06, 0x55, 0xcf, 0xf7, 0xf9, 0x5c, 0xc6, 0xe7, 0xb9, 0x2a, 0xae,
	0xe5, 0xab, 0x38, 0x6f, 0x5b, 0xbd, 0x60, 0x9b, 0x0e, 0xdd, 0x44, 0x4b, 0xa1, 0xf8, 0xaf, 0x1a,
	0xf4, 0x76, 0xfd, 0x90, 0xec, 0xbb, 0x11, 0x25, 0xe1, 0xe7, 0xd5, 0x7f, 0x11, 0xe6, 0x3d, 0xe2,
	0xef, 0xd3, 0x83, 0x38, 0x97, 0xc4, 0x08, 0xf7, 0x01, 0x84, 0xe0, 0x31, 0x13, 0x52, 0x26, 0x38,
	0x67, 0x58, 0xb5, 0x60, 0x98, 0x07, 0xdd, 0x51, 0xe0, 0xec, 0x5d, 0xac, 0xbf, 0x1b, 0xd9, 0xef,
	0xd5, 0xd1, 0x21, 0x99, 0x3a, 0x6e, 0x94, 0x3a, 0x4f, 0x2e, 0x4e, 0x91, 0x37, 0x00, 0x22, 0xf8,
	0x67, 0x4a, 0xba, 0x0e, 0x4d, 0x9f, 0x9c, 0xd8, 0x1c, 0x17, 0x67, 0x68, 0xc3, 0x27, 0x27, 0xe3,
	0x12, 0x5b, 0x8a, 0xec, 0x3f, 0xc2, 0xbc, 0xb0, 0xe3, 0x33, 0xc4, 0x00, 0x7f, 0x03, 0x57, 0x94,
	0xa3, 0x22, 0x93, 0x44, 0xb3, 0xc0, 0x8f, 0x08, 0xba, 0x0f, 0x8d, 0x40, 0x40, 0xb2, 0x8f, 0x5d,
	0x4a, 0xaa, 0x48, 0x66, 0x4b, 0x3c, 0x8f, 0x37, 0xa0, 0x2d, 0xa0, 0xed, 0x90, 0xb0, 0x4b, 0xc1,
	0x22, 0xcc, 0xcf, 0xf8, 0x97, 0x54, 0x53, 0x8e, 0x2e, 0x8e, 0x59, 0x03, 0xea, 0xc3, 0xc3, 0x19,
	0x3d, 0xc5, 0x5d, 0x68, 0x6f, 0x10, 0xca, 0xaa, 0x94, 0x77, 0x73, 0xbc, 0x05, 0x7a, 0x72, 0x09,
	0x5a, 0x0b, 0x7c, 0x4a, 0x7c, 0x8a, 0x9e, 0x42, 0x9b, 0x9b, 0x4c, 0xc4, 0xad, 0x42, 0x6a, 0xa9,
	0x6a, 0x7d, 0xfd, 0xc8, 0xf3, 0xb6, 0x1d, 0x7a, 0xc0, 0x4f, 0x75, 0x73, 0x81, 0xc1, 0xf2, 0x02,
	0x82, 0x7f, 0x80, 0x4e, 0x66, 0x36, 0x75, 0xbd, 0xd1, 0x32, 0xd7, 0x9b, 0x1e, 0xd4, 0x83, 0x03,
	0x27, 0x3a, 0x90, 0x11, 0x13, 0x03, 0x64, 0x40, 0x93, 0xb1, 0xf1, 0x40, 0xcc, 0xf1, 0x89, 0x64,
	0x8c, 0xef, 0x42, 0xe3, 0xc5, 0xb1, 0x68, 0x56, 0x4b, 0xd0, 0x70, 0xa3, 0x35, 0x8f, 0x38, 0xa2,
	0x2d, 0x37, 0xcd, 0x78, 0x88, 0x8f, 0xa1, 0xf1, 0xe2, 0x15, 0xb7, 0x0e, 0x7d, 0x21, 0x5a, 0x55,
	0xac, 0xfe, 0x8d, 0x44, 0x7d, 0xb9, 0x60, 0x99, 0xff, 0x0a, 0x1b, 0xc4, 0x4a, 0xe3, 0x09, 0x80,
	0x02, 0x91, 0x0e, 0x73, 0x3f, 0x13, 0x71, 0x23, 0x6a, 0x99, 0xec, 0x93, 0x29, 0x7d, 0xec, 0x78,
	0x47, 0x22, 0xcd, 0x6a, 0xa6, 0x18, 0x3c, 0xab, 0x3e, 0xd1, 0x1e, 0x6c, 0x43, 0x3b, 0xdd, 0xf7,
	0x11, 0x82, 0xee, 0xab, 0xc9, 0x68, 0x77, 0x6b, 0x68, 0x0f, 0x86, 0xeb, 0xfd, 0xdd, 0x91, 0xa5,
	0x57, 0x50, 0x0f, 0x74, 0x89, 0x59, 0x93, 0xad, 0xd5, 0x1d, 0x6b, 0x32, 0x1e, 0xea, 0x1a, 0x5a,
	0x04, 0x24, 0xd1, 0xd7, 0xf6, 0x60, 0x38, 0x1a, 0x5a, 0x43, 0xbb, 0x6f, 0xe9, 0xd5, 0x07, 0x96,
	0xba, 0x2c, 0x09, 0xa3, 0xdb, 0xd0, 0xdc, 0xb1, 0xfa, 0xd6, 0xd0, 0x36, 0xbf, 0xd7, 0x2b, 0x68,
	0x09, 0x7a, 0x62, 0xb4, 0x36, 0xd9, 0xda, 0xee, 0xaf, 0x59, 0x9b, 0x93, 0xb1, 0xbd, 0x63, 0xae,
	0xe9, 0x1a, 0xba, 0x01, 0xd7, 0x0a, 0x33, 0x56, 0xdf, 0xdc, 0x18, 0x5a, 0x7a, 0xf5, 0xf1, 0x5f,
	0x6d, 0x68, 0x30, 0xca, 0xad, 0xfd, 0x10, 0x6d, 0x82, 0x6e, 0xca, 0x5e, 0x94, 0xdc, 0xa6, 0x96,
	0x12, 0x2f, 0xe5, 0x0e, 0x43, 0xe3, 0x7a, 0xd9, 0x8c, 0xe8, 0x6b, 0x15, 0xf4, 0x35, 0x20, 0xd5,
	0xd8, 0x12, 0xb2, 0xe2, 0xe9, 0xc0, 0xeb, 0xc5, 0xe8, 0x26, 0xb8, 0xc8, 0xc9, 0x0a, 0x5a, 0x83,
	0xae, 0x99, 0x69, 0x8b, 0xa9, 0xbd, 0x99, 0x56, 0x6f, 0x5c, 0x2b, 0xe2, 0xb1, 0x12, 0x23, 0xd0,
	0xf3, 0xdd, 0x15, 0xdd, 0x4a, 0x96, 0x97, 0x35, 0xde, 0x14, 0x5b, 0xee, 0xc8, 0xa9, 0xa0, 0x15,
	0x68, 0x8b, 0xbe, 0x23, 0x99, 0xae, 0x24, 0x4b, 0x55, 0x3b, 0x32, 0x7a, 0x39, 0x30, 0xde, 0xdc,
	0x87, 0x8e, 0x6a, 0x72, 0x03, 0x37, 0x44, 0x57, 0x73, 0x25, 0x2e, 0xea, 0xf9, 0x3c, 0xf9, 0x4f,
	0x41, 0x57, 0x14, 0x05, 0x1d, 0x54, 0x0f, 0x2f, 0xf1, 0xe6, 0x0a, 0x8b, 0xc6, 0xfb, 0x4f, 0xdc,
	0x3c, 0xca, 0x34, 0xad, 0xd5, 0x53, 0xd9, 0x79, 0xce, 0x30, 0xe0, 0x66, 0x02, 0x97, 0x74, 0x3a,
	0xe1, 0x88, 0xcc, 0x0d, 0x12, 0x19, 0x6a, 0x43, 0xfe, 0x66, 0x69, 0xa0, 0x42, 0xbe, 0x44, 0xb8,
	0x82, 0x9e, 0xc1, 0xc2, 0x06, 0xa1, 0x17, 0x26, 0x55, 0xf1, 0x32, 0x88, 0x2b, 0x68, 0x20, 0x1e,
	0x63, 0xea, 0x8d, 0x88, 0x6e, 0x64, 0xe4, 0x67, 0x1f, 0x8f, 0x86, 0x72, 0x91, 0x7a, 0x53, 0xe1,
	0x0a, 0x5a, 0x15, 0x46, 0x24, 0x8b, 0x73, 0x46, 0x64, 0x1e, 0x91, 0x67, 0x71, 0x3c, 0x07, 0x50,
	0xcf, 0x42, 0x74, 0x2d, 0x43, 0xa0, 0xde, 0x8a, 0x67, 0xed, 0x7e, 0x09, 0x8b, 0x19, 0x49, 0x26,
	0x79, 0x77, 0x14, 0x46, 0xee, 0x31, 0x39, 0x57, 0x15, 0x55, 0xb2, 0xf9, 0x16, 0x8f, 0x2b, 0xe8,
	0x8d, 0xa0, 0x2c, 0x3e, 0x0a, 0xd1, 0xdd, 0x0c, 0x65, 0xf9, 0xab, 0xd1, 0x50, 0x7e, 0x2c, 0xbe,
	0x0e, 0x71, 0x05, 0x6d, 0x41, 0xaf, 0x6c, 0xf3, 0xa7, 0xa6, 0xd1, 0x13, 0x00, 0x35, 0x91, 0xf6,
	0x5e, 0xe6, 0x1e, 0x62, 0xe4, 0x0f, 0x52, 0x5c, 0x41, 0xdf, 0x41, 0x27, 0xf3, 0xd6, 0x4a, 0x39,
	0xac, 0xf0, 0x06, 0x4b, 0x19, 0x55, 0x7c, 0x39, 0xe0, 0x0a, 0xfa, 0x0a, 0x9a, 0xf1, 0xd9, 0x99,
	0x32, 0x24, 0x7d, 0x9c, 0x1a, 0x7a, 0xfe, 0x94, 0xe1, 0x49, 0x78, 0x35, 0x53, 0x51, 0x17, 0xa6,
	0x72, 0xd1, 0x8c, 0x47, 0x1a, 0x5a, 0x85, 0x2b, 0xbb, 0xb3, 0x3d, 0x87, 0x92, 0xec, 0xa9, 0x50,
	0xda, 0x96, 0xf9, 0x54, 0x49, 0x6d, 0x3f, 0x02, 0xd8, 0x21, 0x34, 0x3e, 0x45, 0x53, 0xba, 0x1e,
	0x9f, 0xb3, 0x63, 0x43, 0xed, 0xc8, 0xcd, 0x1b, 0x05, 0x06, 0x5c, 0x79, 0x3b, 0xcf, 0xff, 0xa6,
	0xf9, 0xf2, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x69, 0x97, 0xa1, 0xb4, 0x11, 0x00, 0x00,
}
